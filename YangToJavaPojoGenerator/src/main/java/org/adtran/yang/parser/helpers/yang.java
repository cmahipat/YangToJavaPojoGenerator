/* Generated By:JJTree&JavaCC: Do not edit this line. yang.java */
package org.adtran.yang.parser.helpers;
import java.util.Enumeration;
import java.util.Vector;
import java.io.*;

public class yang/*@bgen(jjtree)*/implements yangTreeConstants, yangConstants {/*@bgen(jjtree)*/
  protected static JJTyangState jjtree = new JJTyangState();static private String filename;

  static public void setFileName(String f)
  {
    filename = f;
  }

  static void skip_to(int kind) throws ParseException {
  Token tok = getNextToken();
  //System.out.print("skip : ");  YangErrorManager.addError
  (
    filename, tok.beginLine, tok.beginColumn, "unex_kw", tok.toString()
  )
  ;
  boolean bracked = false;
  if (kind != RB) while (tok.kind != kind)
  {
    // System.out.print(tok);    tok = getNextToken();
  }
  else
  {
    int level = 1;
    boolean close = false;
    while (!close)
    {
      // System.out.print(tok);      if (tok.kind == EOF) close = true;
      if (tok.kind == LB) level++;
      if (tok.kind == RB) level--;
      if (tok.kind == RB && level == 0) close = true;
      if (level < 0) close = true;
      if (!close) tok = getNextToken();
    }
  }
  }

  static final public YANG_Specification Start() throws ParseException {
  YANG_Specification n = null;
    optsep();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case modulekeyword:
      n = module();
      {if (true) return n;}
      break;
    case submodulekeyword:
      n = submodule();
      {if (true) return n;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Specification module() throws ParseException {
 /*@bgen(jjtree) Module */
  YANG_Module jjtn000 = new YANG_Module(JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token mt, t = null;
  Node n = null;
  YANG_Header h = null;
  YANG_Linkage l = null;
  YANG_Meta m = null;
  YANG_Revision r = null;
  YANG_Body b = null;
  String mname = null;
  Token currentToken = null;
    try {
      mt = jj_consume_token(modulekeyword);
      sep();
      mname = identifierargstr();
      optsep();
    jjtn000.setName(mname);
    jjtn000.setLine(mt.beginLine);
    jjtn000.setCol(mt.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setLabel(mt.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_1:
      while (true) {
        h = moduleheaderstmts();
      jjtn000.addHeader(h);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case namespacekeyword:
        case prefixkeyword:
        case yangversionkeyword:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case importkeyword:
        case includekeyword:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        l = linkagestmts();
      jjtn000.addLinkage(l);
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case contactkeyword:
        case descriptionkeyword:
        case organizationkeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        m = metastmts();
      jjtn000.addMeta(m);
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case revisionkeyword:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
        r = revisionstmt();
        stmtsep(jjtn000);
      jjtn000.addRevision(r);
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case augmentkeyword:
        case choicekeyword:
        case containerkeyword:
        case extensionkeyword:
        case deviationkeyword:
        case featurekeyword:
        case groupingkeyword:
        case identitykeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case notificationkeyword:
        case rpckeyword:
        case typedefkeyword:
        case useskeyword:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_5;
        }
        b = bodystmts();
      jjtn000.addBody(b);
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Specification submodule() throws ParseException {
 /*@bgen(jjtree) SubModule */
  YANG_SubModule jjtn000 = new YANG_SubModule(JJTSUBMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Header sh = null;
  YANG_Linkage l = null;
  YANG_Meta s = null;
  YANG_Revision r = null;
  YANG_Body b = null;
  Token st, t;
  String mname = "";
    try {
      st = jj_consume_token(submodulekeyword);
      sep();
      mname = identifierargstr();
      optsep();
    jjtn000.setSubModule(mname);
    jjtn000.setLine(st.beginLine);
    jjtn000.setCol(st.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setLabel(st.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_6:
      while (true) {
        sh = submoduleheaderstmts();
      jjtn000.addHeader(sh);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case belongstokeyword:
        case yangversionkeyword:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_6;
        }
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case importkeyword:
        case includekeyword:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_7;
        }
        l = linkagestmts();
      jjtn000.addLinkage(l);
      }
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case contactkeyword:
        case descriptionkeyword:
        case organizationkeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_8;
        }
        s = metastmts();
      jjtn000.addMeta(s);
      }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case revisionkeyword:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_9;
        }
        r = revisionstmt();
        stmtsep(jjtn000);
      jjtn000.addRevision(r);
      }
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case augmentkeyword:
        case choicekeyword:
        case containerkeyword:
        case extensionkeyword:
        case deviationkeyword:
        case featurekeyword:
        case groupingkeyword:
        case identitykeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case notificationkeyword:
        case rpckeyword:
        case typedefkeyword:
        case useskeyword:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_10;
        }
        b = bodystmts();
      jjtn000.addBody(b);
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Header moduleheaderstmts() throws ParseException {
  YANG_Header h = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case yangversionkeyword:
      h = yangversionstmt();
      stmtsep(h);
      break;
    case namespacekeyword:
      h = namespacestmt();
      stmtsep(h);
      break;
    case prefixkeyword:
      h = prefixstmt();
      stmtsep(h);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return h;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Header submoduleheaderstmts() throws ParseException {
  YANG_Header h = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case belongstokeyword:
      h = belongstostmt();
      stmtsep(h);
      break;
    case yangversionkeyword:
      h = yangversionstmt();
      stmtsep(h);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return h;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Meta metastmts() throws ParseException {
  YANG_Meta n = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case organizationkeyword:
      n = organizationstmt();
      stmtsep(n);
      break;
    case contactkeyword:
      n = contactstmt();
      stmtsep(n);
      break;
    case descriptionkeyword:
      n = descriptionstmt();
      stmtsep(n);
      break;
    case referencekeyword:
      n = referencestmt();
      stmtsep(n);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return (YANG_Meta) n;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Linkage linkagestmts() throws ParseException {
  YANG_Linkage n = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case importkeyword:
      n = importstmt();
      stmtsep(n);
      break;
    case includekeyword:
      n = includestmt();
      stmtsep(n);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Body bodystmts() throws ParseException {
  YANG_Body b = null;
  boolean ended = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case extensionkeyword:
      b = extensionstmt();
      break;
    case featurekeyword:
      b = featurestmt();
      break;
    case identitykeyword:
      b = identitystmt();
      break;
    case typedefkeyword:
      b = typedefstmt();
      break;
    case groupingkeyword:
      b = groupingstmt();
      break;
    case anyxmlkeyword:
    case choicekeyword:
    case containerkeyword:
    case leafkeyword:
    case leaflistkeyword:
    case listkeyword:
    case useskeyword:
      b = datadefstmt();
      break;
    case augmentkeyword:
      b = augmentstmt();
      break;
    case rpckeyword:
      b = rpcstmt();
      break;
    case notificationkeyword:
      b = notificationstmt();
      break;
    case deviationkeyword:
      b = deviationstmt();
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    stmtsep(b);
    {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_DataDef datadefstmt() throws ParseException {
  YANG_DataDef d = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case containerkeyword:
      d = containerstmt();
      break;
    case leafkeyword:
      d = leafstmt();
      break;
    case leaflistkeyword:
      d = leafliststmt();
      break;
    case listkeyword:
      d = liststmt();
      break;
    case choicekeyword:
      d = choicestmt();
      break;
    case anyxmlkeyword:
      d = anyxmlstmt();
      break;
    case useskeyword:
      d = usesstmt();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return d;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_YangVersion yangversionstmt() throws ParseException {
 /*@bgen(jjtree) YangVersion */
  YANG_YangVersion jjtn000 = new YANG_YangVersion(JJTYANGVERSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token yt;
  String y = null;
    try {
      yt = jj_consume_token(yangversionkeyword);
      sep();
      y = yangversionargstr();
      optsep();
      stmtend(jjtn000);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setVersion(y);
    jjtn000.setFileName(filename);
    jjtn000.setLine(yt.beginLine);
    jjtn000.setCol(yt.beginColumn);
    jjtn000.setLabel(yt.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String yangversionargstr() throws ParseException {
  String y = null;
    //< a string which matches the rule
      // yang-version-arg >
      y = stringoroneword();
    {if (true) return y;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Import importstmt() throws ParseException {
 /*@bgen(jjtree) Import */
  YANG_Import jjtn000 = new YANG_Import(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  YANG_Prefix n = null;
  String i;
  YANG_Revision r = null;
    try {
      t = jj_consume_token(importkeyword);
      sep();
      i = identifierargstr();
      optsep();
    jjtn000.setIdentifier(i);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case prefixkeyword:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_11;
        }
        n = prefixstmt();
        stmtsep(jjtn000);
      jjtn000.setPrefix(n);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case revisiondatekeyword:
          r = revisiondatestmt();
          stmtsep(jjtn000);
        jjtn000.setRevision(r);
          break;
        default:
          jj_la1[18] = jj_gen;
          ;
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Include includestmt() throws ParseException {
 /*@bgen(jjtree) Include */
  YANG_Include jjtn000 = new YANG_Include(JJTINCLUDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String i;
  YANG_Revision r = null;
    try {
      t = jj_consume_token(includekeyword);
      sep();
      i = identifierargstr();
      optsep();
    jjtn000.setIdentifier(i);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC:
        jj_consume_token(SC);
        break;
      case LB:
        jj_consume_token(LB);
        stmtsep(jjtn000);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case revisiondatekeyword:
          r = revisiondatestmt();
          stmtsep(jjtn000);
        jjtn000.setRevision(r);
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
        jj_consume_token(RB);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_NameSpace namespacestmt() throws ParseException {
 /*@bgen(jjtree) NameSpace */
  YANG_NameSpace jjtn000 = new YANG_NameSpace(JJTNAMESPACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String uri;
  Token t, tn;
    try {
      t = jj_consume_token(namespacekeyword);
      sep();
      uri = uristr();
      optsep();
      stmtend(jjtn000);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setNameSpace(uri);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String uristr() throws ParseException {
  Token u, p;
  String s = "";
    s = stringoroneword();
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Prefix prefixstmt() throws ParseException {
 /*@bgen(jjtree) Prefix */
  YANG_Prefix jjtn000 = new YANG_Prefix(JJTPREFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String s;
  Token t;
    try {
      t = jj_consume_token(prefixkeyword);
      sep();
      s = prefixargstr();
      optsep();
      stmtend(jjtn000);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setPrefix(s);
    jjtn000.setLabel(t.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Belong belongstostmt() throws ParseException {
 /*@bgen(jjtree) Belong */
  YANG_Belong jjtn000 = new YANG_Belong(JJTBELONG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String b = null;
  YANG_Prefix p = null;
    try {
      t = jj_consume_token(belongstokeyword);
      sep();
      b = identifierargstr();
      optsep();
      jj_consume_token(LB);
      stmtsep(jjtn000);
      p = prefixstmt();
      stmtsep(jjtn000);
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setBelong(b);
    jjtn000.setPrefix(p);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Organization organizationstmt() throws ParseException {
 /*@bgen(jjtree) Organization */
  YANG_Organization jjtn000 = new YANG_Organization(JJTORGANIZATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s;
    try {
      t = jj_consume_token(organizationkeyword);
      sep();
      s = stringoroneword();
      optsep();
      stmtend(jjtn000);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setOrganization(s);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Contact contactstmt() throws ParseException {
 /*@bgen(jjtree) Contact */
  YANG_Contact jjtn000 = new YANG_Contact(JJTCONTACT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String c;
    try {
      t = jj_consume_token(contactkeyword);
      sep();
      c = stringoroneword();
      optsep();
      stmtend(jjtn000);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setContact(c);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Description descriptionstmt() throws ParseException {
 /*@bgen(jjtree) Description */
  YANG_Description jjtn000 = new YANG_Description(JJTDESCRIPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String d = "";
    try {
      try {
        t = jj_consume_token(descriptionkeyword);
        sep();
        d = stringoroneword();
        optsep();
        stmtend(jjtn000);
      jjtn000.setDescription(d);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Reference referencestmt() throws ParseException {
 /*@bgen(jjtree) Reference */
  YANG_Reference jjtn000 = new YANG_Reference(JJTREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String r;
    try {
      try {
        t = jj_consume_token(referencekeyword);
        sep();
        r = stringoroneword();
        optsep();
        stmtend(jjtn000);
      jjtn000.setReference(r);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Units unitsstmt() throws ParseException {
 /*@bgen(jjtree) Units */
  YANG_Units jjtn000 = new YANG_Units(JJTUNITS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t, ut;
  String u = null;
    try {
      try {
        t = jj_consume_token(unitskeyword);
        sep();
        u = stringoroneword();
        optsep();
        stmtend(jjtn000);
      jjtn000.setUnits(u);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Revision revisionstmt() throws ParseException {
 /*@bgen(jjtree) Revision */
  YANG_Revision jjtn000 = new YANG_Revision(JJTREVISION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  YANG_Description d = null;
  YANG_Reference r = null;
  String da = null;
    try {
      try {
        t = jj_consume_token(revisionkeyword);
        sep();
        da = revisiondate();
        optsep();
      jjtn000.setDate(da);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case descriptionkeyword:
            d = descriptionstmt();
            stmtsep(jjtn000);
            break;
          default:
            jj_la1[21] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case referencekeyword:
            r = referencestmt();
            stmtsep(jjtn000);
            break;
          default:
            jj_la1[22] = jj_gen;
            ;
          }
          jj_consume_token(RB);
      if (d != null) jjtn000.setDescription(d);
      if (r != null) jjtn000.setReference(r);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String revisiondate() throws ParseException {
  String r = null;
    r = dateargstr();
    {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Revision revisiondatestmt() throws ParseException {
 /*@bgen(jjtree) Revision */
  YANG_Revision jjtn000 = new YANG_Revision(JJTREVISION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  YANG_Description d = null;
  String da = null;
    try {
      try {
        t = jj_consume_token(revisiondatekeyword);
        sep();
        da = revisiondate();
        stmtend(jjtn000);
      jjtn000.setDate(da);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Extension extensionstmt() throws ParseException {
 /*@bgen(jjtree) Extension */
  YANG_Extension jjtn000 = new YANG_Extension(JJTEXTENSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  String s = null;
  YANG_Argument a = null;
  YANG_Status st = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        t = jj_consume_token(extensionkeyword);
        sep();
        s = identifierargstr();
        optsep();
      jjtn000.setExtension(s);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case argumentkeyword:
            case descriptionkeyword:
            case referencekeyword:
            case statuskeyword:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_12;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case argumentkeyword:
              //extensionAnyOrder()
                  a = argumentstmt();
              stmtsep(jjtn000);
      jjtn000.setArgument(a);
              break;
            case statuskeyword:
              st = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(st);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[25] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Argument argumentstmt() throws ParseException {
 /*@bgen(jjtree) Argument */
  YANG_Argument jjtn000 = new YANG_Argument(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  YANG_Yin y = null;
  String i = null;
  Token t, a;
  String any = "";
    try {
      try {
        t = jj_consume_token(argumentkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setArgument(i);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case yinelementkeyword:
            y = yinelementstmt();
            stmtsep(jjtn000);
        jjtn000.setYin(y);
            break;
          default:
            jj_la1[27] = jj_gen;
            ;
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Yin yinelementstmt() throws ParseException {
 /*@bgen(jjtree) Yin */
  YANG_Yin jjtn000 = new YANG_Yin(JJTYIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String y = null;
    try {
      try {
        t = jj_consume_token(yinelementkeyword);
        sep();
        y = yinelementargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setYin(y);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String yinelementargstr() throws ParseException {
  String y = null;
    //< a string which matches the rule
      //   yinelementarg >
      y = stringoroneword();
    {if (true) return y;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Identity identitystmt() throws ParseException {
 /*@bgen(jjtree) Identity */
  YANG_Identity jjtn000 = new YANG_Identity(JJTIDENTITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  String i = null;
  YANG_Base b = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        t = jj_consume_token(identitykeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setIdentity(i);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          optsep();
          label_13:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case basekeyword:
            case descriptionkeyword:
            case referencekeyword:
            case statuskeyword:
              ;
              break;
            default:
              jj_la1[29] = jj_gen;
              break label_13;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case basekeyword:
              b = basestmt();
              stmtsep(jjtn000);
      jjtn000.setBase(b);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[30] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Base basestmt() throws ParseException {
 /*@bgen(jjtree) Base */
  YANG_Base jjtn000 = new YANG_Base(JJTBASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String i = null;
    try {
      try {
        t = jj_consume_token(basekeyword);
        sep();
        i = identifierrefargstr();
        stmtend(jjtn000);
      jjtn000.setBase(i);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Feature featurestmt() throws ParseException {
 /*@bgen(jjtree) Feature */
  YANG_Feature jjtn000 = new YANG_Feature(JJTFEATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  String f = null;
  YANG_IfFeature i = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        t = jj_consume_token(featurekeyword);
        sep();
        f = identifierargstr();
        optsep();
      jjtn000.setFeature(f);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_14:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case iffeaturekeyword:
            case referencekeyword:
            case statuskeyword:
              ;
              break;
            default:
              jj_la1[32] = jj_gen;
              break label_14;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case iffeaturekeyword:
              i = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(i);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[33] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_IfFeature iffeaturestmt() throws ParseException {
 /*@bgen(jjtree) IfFeature */
  YANG_IfFeature jjtn000 = new YANG_IfFeature(JJTIFFEATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String i = null;
    try {
      try {
        t = jj_consume_token(iffeaturekeyword);
        sep();
        i = identifierrefargstr();
        stmtend(jjtn000);
      jjtn000.setIfFeature(i);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_TypeDef typedefstmt() throws ParseException {
 /*@bgen(jjtree) TypeDef */
  YANG_TypeDef jjtn000 = new YANG_TypeDef(JJTTYPEDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String i = null;
  YANG_Type ty = null;
  YANG_Units u = null;
  YANG_Default df = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      t = jj_consume_token(typedefkeyword);
      sep();
      i = identifierargstr();
      optsep();
    jjtn000.setTypedef(i);
    jjtn000.setFileName(filename);
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setLabel(t.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case defaultkeyword:
        case descriptionkeyword:
        case referencekeyword:
        case statuskeyword:
        case typekeyword:
        case unitskeyword:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_15;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case typekeyword:
          ty = typestmt();
          stmtsep(jjtn000);
      jjtn000.setType(ty);
          break;
        case unitskeyword:
          u = unitsstmt();
          stmtsep(jjtn000);
      jjtn000.setUnits(u);
          break;
        case defaultkeyword:
          df = defaultstmt();
          stmtsep(jjtn000);
      jjtn000.setDefault(df);
          break;
        case statuskeyword:
          s = statusstmt();
          stmtsep(jjtn000);
      jjtn000.setStatus(s);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Type typestmt() throws ParseException {
 /*@bgen(jjtree) Type */
  YANG_Type jjtn000 = new YANG_Type(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  boolean header = false, lb = false;
  String it = null;
  YANG_Base i = null;
  String ii = null;
  YANG_Enum e = null;
  YANG_Decimal64Spec d = null;
  YANG_LeafRefSpecification k = null;
  YANG_BitSpecification b = null;
  YANG_UnionSpecification u = null;
  YANG_NumericalRestriction n = null;
  YANG_StringRestriction s = null;
    try {
      try {
        t = jj_consume_token(typekeyword);
        sep();
        it = identifierrefargstr();
        optsep();
      jjtn000.setType(it);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      header = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_16:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case basekeyword:
            case bitkeyword:
            case enumkeyword:
            case fractiondigitskeyword:
            case lengthkeyword:
            case pathkeyword:
            case patternkeyword:
            case rangekeyword:
            case requireinstancekeyword:
            case typekeyword:
              ;
              break;
            default:
              jj_la1[37] = jj_gen;
              break label_16;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case rangekeyword:
              n = numericalrestrictions();
      jjtn000.setNumRest(n);
              break;
            case fractiondigitskeyword:
              d = decimal64specification();
      jjtn000.setDec64Spec(d);
              break;
            case lengthkeyword:
            case patternkeyword:
              s = stringrestrictions();
      jjtn000.setStringRest(s);
              break;
            case enumkeyword:
              label_17:
              while (true) {
                e = enumstmt();
                optsep();
      jjtn000.addEnum(e);
                if (jj_2_1(2)) {
                  ;
                } else {
                  break label_17;
                }
              }
              break;
            default:
              jj_la1[38] = jj_gen;
              if (jj_2_2(2)) {
                k = leafrefspecification();
      jjtn000.setLeafRef(k);
              } else if (jj_2_3(2)) {
                u = unionspecification();
      jjtn000.setUnionSpec(u);
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case requireinstancekeyword:
                  ii = instanceidentifierspecification(jjtn000);
      jjtn000.setInstanceIdentifierSpec(ii);
                  break;
                case basekeyword:
                  i = identityrefspecification(jjtn000);
      jjtn000.setIdentityRefSpec(i);
                  break;
                case bitkeyword:
                  b = bitsspecification();
      jjtn000.setBitSpec(b);
                  break;
                default:
                  jj_la1[39] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
              }
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException pe) {
    if (lb)
    {
      skip_to(RB);
    }
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_NumericalRestriction numericalrestrictions() throws ParseException {
  YANG_Range r = null;
    r = rangestmt();
    stmtsep(r);
    {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Range rangestmt() throws ParseException {
 /*@bgen(jjtree) Range */
  YANG_Range jjtn000 = new YANG_Range(JJTRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  String r = null;
  YANG_ErrorMessage errmess = null;
  YANG_ErrorAppt eat = null;
  YANG_Description d = null;
  YANG_Reference re = null;
  Token rt = null;
    try {
      try {
        rt = jj_consume_token(rangekeyword);
        sep();
        r = rangeargstr();
        optsep();
      jjtn000.setLine(rt.beginLine);
      jjtn000.setCol(rt.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(rt.image);
      jjtn000.setRange(r);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_18:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case errorapptagkeyword:
            case errormessagekeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[41] = jj_gen;
              break label_18;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case errormessagekeyword:
              errmess = errormessagestmt();
              stmtsep(jjtn000);
      jjtn000.setErrMess(errmess);
              break;
            case errorapptagkeyword:
              eat = errorapptagstmt();
              stmtsep(jjtn000);
      jjtn000.setErrAppTag(eat);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              re = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(re);
              break;
            default:
              jj_la1[42] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Decimal64Spec decimal64specification() throws ParseException {
 /*@bgen(jjtree) Decimal64Spec */
  YANG_Decimal64Spec jjtn000 = new YANG_Decimal64Spec(JJTDECIMAL64SPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String s = null;
  YANG_Range r = null;
    try {
      s = fractiondigitstmt(jjtn000);
      optsep();
      if (jj_2_4(2)) {
        r = rangestmt();
        jjtn000.setRange(r);
      } else {
        ;
      }
      optsep();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.setFractionDigit(s);
      jjtn000.setFileName(filename);
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String fractiondigitstmt(YANG_Decimal64Spec j) throws ParseException {
  Token f = null;
  String s = null;
    f = jj_consume_token(fractiondigitskeyword);
    sep();
    s = fractiondigitargstr();
    stmtend(j);
    j.setLine(f.beginLine);
    j.setCol(f.beginColumn);
    j.setLabel(f.image);
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public String fractiondigitargstr() throws ParseException {
  String f = null;
    f = stringoroneword();
    {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_StringRestriction stringrestrictions() throws ParseException {
 /*@bgen(jjtree) StringRestriction */
  YANG_StringRestriction jjtn000 = new YANG_StringRestriction(JJTSTRINGRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Length l = null;
  YANG_Pattern p = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lengthkeyword:
        l = lengthstmt();
        stmtsep(jjtn000);
        jjtn000.setLine(l.getLine());
        jjtn000.setCol(l.getCol());
        jjtn000.setFileName(filename);
        jjtn000.setLength(l);
        label_19:
        while (true) {
          if (jj_2_5(2)) {
            ;
          } else {
            break label_19;
          }
          p = patternstmt();
          stmtsep(jjtn000);
          jjtn000.setLine(p.getLine());
          jjtn000.setCol(p.getCol());
          jjtn000.setFileName(filename);
          jjtn000.addPattern(p);
        }
        break;
      case patternkeyword:
        label_20:
        while (true) {
          p = patternstmt();
          stmtsep(jjtn000);
        jjtn000.setLine(p.getLine());
        jjtn000.setCol(p.getCol());
        jjtn000.setFileName(filename);
        jjtn000.addPattern(p);
          if (jj_2_6(2)) {
            ;
          } else {
            break label_20;
          }
        }
        if (jj_2_7(2)) {
          l = lengthstmt();
          stmtsep(jjtn000);
        jjtn000.setLine(l.getLine());
        jjtn000.setCol(l.getCol());
        jjtn000.setFileName(filename);
        jjtn000.setLength(l);
        } else {
          ;
        }
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Length lengthstmt() throws ParseException {
 /*@bgen(jjtree) Length */
  YANG_Length jjtn000 = new YANG_Length(JJTLENGTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  String l = null;
  YANG_ErrorMessage em = null;
  YANG_ErrorAppt eat = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token lk;
    try {
      try {
        lk = jj_consume_token(lengthkeyword);
        sep();
        l = lengthargstr();
        optsep();
      jjtn000.setLine(lk.beginLine);
      jjtn000.setCol(lk.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(lk.image);
      jjtn000.setLength(l);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_21:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case errorapptagkeyword:
            case errormessagekeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[45] = jj_gen;
              break label_21;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case errormessagekeyword:
              em = errormessagestmt();
              stmtsep(jjtn000);
      jjtn000.setErrMess(em);
              break;
            case errorapptagkeyword:
              eat = errorapptagstmt();
              stmtsep(jjtn000);
      jjtn000.setErrAppTag(eat);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[46] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Pattern patternstmt() throws ParseException {
 /*@bgen(jjtree) Pattern */
  YANG_Pattern jjtn000 = new YANG_Pattern(JJTPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  String pa = null;
  YANG_ErrorMessage em = null;
  YANG_ErrorAppt eat = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t;
    try {
      try {
        t = jj_consume_token(patternkeyword);
        sep();
        pa = stringoroneword();
        optsep();
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
      jjtn000.setPattern(pa);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_22:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case errorapptagkeyword:
            case errormessagekeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[48] = jj_gen;
              break label_22;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case errormessagekeyword:
              em = errormessagestmt();
              stmtsep(jjtn000);
      jjtn000.setErrMess(em);
              break;
            case errorapptagkeyword:
              eat = errorapptagstmt();
              stmtsep(jjtn000);
      jjtn000.setErrAppTag(eat);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[49] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Default defaultstmt() throws ParseException {
 /*@bgen(jjtree) Default */
  YANG_Default jjtn000 = new YANG_Default(JJTDEFAULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t, dt;
  String d = null;
    try {
      try {
        t = jj_consume_token(defaultkeyword);
        sep();
        d = stringoroneword();
        stmtend(jjtn000);
      jjtn000.setDefault(d);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Enum enumstmt() throws ParseException {
 /*@bgen(jjtree) Enum */
  YANG_Enum jjtn000 = new YANG_Enum(JJTENUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  String e = null;
  YANG_Value v = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t, te;
    try {
      try {
        t = jj_consume_token(enumkeyword);
        sep();
        e = stringoroneword();
        optsep();
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setEnum(e);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_23:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case referencekeyword:
            case statuskeyword:
            case valuekeyword:
              ;
              break;
            default:
              jj_la1[51] = jj_gen;
              break label_23;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case valuekeyword:
              v = valuestmt();
              stmtsep(jjtn000);
      jjtn000.setValue(v);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[52] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_LeafRefSpecification leafrefspecification() throws ParseException {
 /*@bgen(jjtree) LeafRefSpecification */
  YANG_LeafRefSpecification jjtn000 = new YANG_LeafRefSpecification(JJTLEAFREFSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Path p = null;
  String r = null;
    try {
      p = pathstmt();
      stmtsep(jjtn000);
      jjtn000.setPath(p);
      jjtn000.setFileName(filename);
      if (jj_2_8(2)) {
        r = requireinstancestmt(jjtn000);
        stmtsep(jjtn000);
      } else {
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    if (r != null) jjtn000.setRequireInstance(r);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Path pathstmt() throws ParseException {
 /*@bgen(jjtree) Path */
  YANG_Path jjtn000 = new YANG_Path(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String pa = null;
  Token t;
    try {
      try {
        t = jj_consume_token(pathkeyword);
        sep();
        pa = pathargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setPath(pa);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String requireinstancestmt(YangNode j) throws ParseException {
  String s = null;
    jj_consume_token(requireinstancekeyword);
    sep();
    s = requireinstanceargstr();
    stmtend(j);
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public String requireinstanceargstr() throws ParseException {
  String r = null;
    r = stringoroneword();
    {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  static final public String instanceidentifierspecification(YangNode j) throws ParseException {
  String s = null;
    //[                                        No conform because it is not usefulness
      s = requireinstancestmt(j);
    stmtsep(j);
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Base identityrefspecification(YangNode j) throws ParseException {
  YANG_Base b = null;
    b = basestmt();
    stmtsep(j);
    {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_UnionSpecification unionspecification() throws ParseException {
 /*@bgen(jjtree) UnionSpecification */
  YANG_UnionSpecification jjtn000 = new YANG_UnionSpecification(JJTUNIONSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Type t = null;
    try {
      try {
        label_24:
        while (true) {
          t = typestmt();
          stmtsep(jjtn000);
      jjtn000.addType(t);
          if (jj_2_9(2)) {
            ;
          } else {
            break label_24;
          }
        }
      jjtn000.setFileName(filename);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_BitSpecification bitsspecification() throws ParseException {
 /*@bgen(jjtree) BitSpecification */
  YANG_BitSpecification jjtn000 = new YANG_BitSpecification(JJTBITSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Bit b = null;
    try {
      label_25:
      while (true) {
        b = bitstmt();
        stmtsep(jjtn000);
      jjtn000.setLabel("bits");
      jjtn000.addBit(b);
        if (jj_2_10(2)) {
          ;
        } else {
          break label_25;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Bit bitstmt() throws ParseException {
 /*@bgen(jjtree) Bit */
  YANG_Bit jjtn000 = new YANG_Bit(JJTBIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  String i = null;
  YANG_Position po = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t = null;
    try {
      try {
        t = jj_consume_token(bitkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setBit(i);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_26:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case positionkeyword:
            case referencekeyword:
            case statuskeyword:
              ;
              break;
            default:
              jj_la1[54] = jj_gen;
              break label_26;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case positionkeyword:
              po = positionstmt();
              stmtsep(jjtn000);
      jjtn000.setPosition(po);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[55] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Position positionstmt() throws ParseException {
 /*@bgen(jjtree) Position */
  YANG_Position jjtn000 = new YANG_Position(JJTPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String po = null;
  Token t = null;
    try {
      try {
        t = jj_consume_token(positionkeyword);
        sep();
        po = positionvalueargstr();
        stmtend(jjtn000);
      jjtn000.setPosition(po);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String positionvalueargstr() throws ParseException {
  String p = null;
    // < a string which matches the rule
      //  positionvaluearg >
      p = stringoroneword();
    {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Status statusstmt() throws ParseException {
 /*@bgen(jjtree) Status */
  YANG_Status jjtn000 = new YANG_Status(JJTSTATUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s = null;
    try {
      try {
        t = jj_consume_token(statuskeyword);
        sep();
        s = statusargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setStatus(s);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String statusargstr() throws ParseException {
  String s = null;
    s = stringoroneword();
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Config configstmt() throws ParseException {
 /*@bgen(jjtree) Config */
  YANG_Config jjtn000 = new YANG_Config(JJTCONFIG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String c = null;
    try {
      try {
        t = jj_consume_token(configkeyword);
        sep();
        c = configargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setConfig(c);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String configargstr() throws ParseException {
  String c = null;
    //	< a string which matches the rule
      //           configarg >
      c = stringoroneword();
    {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Mandatory mandatorystmt() throws ParseException {
 /*@bgen(jjtree) Mandatory */
  YANG_Mandatory jjtn000 = new YANG_Mandatory(JJTMANDATORY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String m = null;
    try {
      try {
        t = jj_consume_token(mandatorykeyword);
        sep();
        m = mandatoryargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setMandatory(m);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String mandatoryargstr() throws ParseException {
  String m = null;
    //< a string which matches the rule
      //   mandatoryarg >
      m = stringoroneword();
    {if (true) return m;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Presence presencestmt() throws ParseException {
 /*@bgen(jjtree) Presence */
  YANG_Presence jjtn000 = new YANG_Presence(JJTPRESENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String pr = null;
    try {
      try {
        t = jj_consume_token(presencekeyword);
        sep();
        pr = stringoroneword();
        stmtend(jjtn000);
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setPresence(pr);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_OrderedBy orderedbystmt() throws ParseException {
 /*@bgen(jjtree) OrderedBy */
  YANG_OrderedBy jjtn000 = new YANG_OrderedBy(JJTORDEREDBY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String o = null;
    try {
      try {
        t = jj_consume_token(orderedbykeyword);
        sep();
        o = orderedbyargstr();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setOrderedBy(o);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String orderedbyargstr() throws ParseException {
  String o = null;
    //	< a string which matches the rule
      //           orderedbyarg >
      o = stringoroneword();
    {if (true) return o;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Must muststmt() throws ParseException {
 /*@bgen(jjtree) Must */
  YANG_Must jjtn000 = new YANG_Must(JJTMUST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token must;
  String m = null;
  YANG_ErrorMessage em = null;
  YANG_ErrorAppt ea = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        must = jj_consume_token(mustkeyword);
        sep();
        m = string();
        optsep();
      jjtn000.setLine(must.beginLine);
      jjtn000.setCol(must.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(must.image);
      jjtn000.setMust(m);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_27:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case errorapptagkeyword:
            case errormessagekeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[57] = jj_gen;
              break label_27;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case errormessagekeyword:
              em = errormessagestmt();
              stmtsep(jjtn000);
      jjtn000.setErrMess(em);
              break;
            case errorapptagkeyword:
              ea = errorapptagstmt();
              stmtsep(jjtn000);
      jjtn000.setErrAppTag(ea);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[58] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[59] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_ErrorMessage errormessagestmt() throws ParseException {
 /*@bgen(jjtree) ErrorMessage */
  YANG_ErrorMessage jjtn000 = new YANG_ErrorMessage(JJTERRORMESSAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String e = null;
    try {
      try {
        t = jj_consume_token(errormessagekeyword);
        sep();
        e = stringoroneword();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setErrorMessage(e);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_ErrorAppt errorapptagstmt() throws ParseException {
 /*@bgen(jjtree) ErrorAppt */
  YANG_ErrorAppt jjtn000 = new YANG_ErrorAppt(JJTERRORAPPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String e = null;
    try {
      try {
        t = jj_consume_token(errorapptagkeyword);
        sep();
        e = stringoroneword();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setErrorAppt(e);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_MinElement minelementsstmt() throws ParseException {
 /*@bgen(jjtree) MinElement */
  YANG_MinElement jjtn000 = new YANG_MinElement(JJTMINELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String m = null;
    try {
      try {
        t = jj_consume_token(minelementskeyword);
        sep();
        m = minvalueargstr();
        stmtend(jjtn000);
      jjtn000.setMinElement(m);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String minvalueargstr() throws ParseException {
  String m = null;
    //	< a string which matches the rule
      //         minvaluearg >
      m = stringoroneword();
    {if (true) return m;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_MaxElement maxelementsstmt() throws ParseException {
 /*@bgen(jjtree) MaxElement */
  YANG_MaxElement jjtn000 = new YANG_MaxElement(JJTMAXELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String m = null;
    try {
      try {
        t = jj_consume_token(maxelementskeyword);
        sep();
        m = maxvalueargstr();
        stmtend(jjtn000);
      jjtn000.setFileName(filename);
      jjtn000.setMaxElement(m);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String maxvalueargstr() throws ParseException {
  String m = null;
    //	< a string which matches the rule
      //           maxvalue >
      m = stringoroneword();
    {if (true) return m;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Value valuestmt() throws ParseException {
 /*@bgen(jjtree) Value */
  YANG_Value jjtn000 = new YANG_Value(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String d = null;
  Token t = null;
    try {
      try {
        t = jj_consume_token(valuekeyword);
        sep();
        d = stringoroneword();
        stmtend(jjtn000);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setValue(d);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Body groupingstmt() throws ParseException {
 /*@bgen(jjtree) Grouping */
  YANG_Grouping jjtn000 = new YANG_Grouping(JJTGROUPING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token to;
  String i = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef dd = null;
    try {
      try {
        to = jj_consume_token(groupingkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setFileName(filename);
      jjtn000.setLine(to.beginLine);
      jjtn000.setCol(to.beginColumn);
      jjtn000.setGrouping(i);
      jjtn000.setLabel(to.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_28:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case descriptionkeyword:
            case groupingkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case referencekeyword:
            case statuskeyword:
            case typedefkeyword:
            case useskeyword:
              ;
              break;
            default:
              jj_la1[60] = jj_gen;
              break label_28;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case groupingkeyword:
            case typedefkeyword:
              label_29:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case typedefkeyword:
                  t = typedefstmt();
      jjtn000.addTypeDef(t);
                  break;
                case groupingkeyword:
                  g = groupingstmt();
      if (g instanceof YANG_Grouping) jjtn000.addGrouping((YANG_Grouping) g);
                  break;
                default:
                  jj_la1[61] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                stmtsep(jjtn000);
                if (jj_2_11(2)) {
                  ;
                } else {
                  break label_29;
                }
              }
              break;
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case useskeyword:
              dd = datadefstmt();
              stmtsep(jjtn000);
      jjtn000.addDataDef(dd);
              break;
            default:
              jj_la1[62] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[63] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException pe) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Container containerstmt() throws ParseException {
 /*@bgen(jjtree) Container */
  YANG_Container jjtn000 = new YANG_Container(JJTCONTAINER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token to;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Must m = null;
  YANG_Presence p = null;
  YANG_Config c = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef da = null;
    try {
      try {
        to = jj_consume_token(containerkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setFileName(filename);
      jjtn000.setLine(to.beginLine);
      jjtn000.setCol(to.beginColumn);
      jjtn000.setContainer(i);
      jjtn000.setLabel(to.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_30:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case anyxmlkeyword:
            case choicekeyword:
            case configkeyword:
            case containerkeyword:
            case descriptionkeyword:
            case groupingkeyword:
            case iffeaturekeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case mustkeyword:
            case presencekeyword:
            case referencekeyword:
            case statuskeyword:
            case typedefkeyword:
            case useskeyword:
            case whenkeyword:
              ;
              break;
            default:
              jj_la1[64] = jj_gen;
              break label_30;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case whenkeyword:
              w = whenstmt();
              stmtsep(jjtn000);
      jjtn000.setWhen(w);
              break;
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case mustkeyword:
              m = muststmt();
              stmtsep(jjtn000);
      jjtn000.addMust(m);
              break;
            case presencekeyword:
              p = presencestmt();
              stmtsep(jjtn000);
      jjtn000.setPresence(p);
              break;
            case configkeyword:
              c = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(c);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case groupingkeyword:
            case typedefkeyword:
              label_31:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case typedefkeyword:
                  t = typedefstmt();
      jjtn000.addTypeDef(t);
                  break;
                case groupingkeyword:
                  g = groupingstmt();
      jjtn000.addGrouping((YANG_Grouping) g);
                  break;
                default:
                  jj_la1[65] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                stmtsep(jjtn000);
                if (jj_2_12(2)) {
                  ;
                } else {
                  break label_31;
                }
              }
              break;
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case useskeyword:
              da = datadefstmt();
              stmtsep(jjtn000);
      jjtn000.addDataDef(da);
              break;
            default:
              jj_la1[66] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException pe) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Leaf leafstmt() throws ParseException {
 /*@bgen(jjtree) Leaf */
  YANG_Leaf jjtn000 = new YANG_Leaf(JJTLEAF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token leaf;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Type t = null;
  YANG_Units u = null;
  YANG_Must m = null;
  YANG_Default d = null;
  YANG_Config c = null;
  YANG_Mandatory ma = null;
  YANG_Status s = null;
  YANG_Description de = null;
  YANG_Reference r = null;
    try {
      try {
        leaf = jj_consume_token(leafkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(leaf.beginLine);
      jjtn000.setCol(leaf.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLeaf(i);
      jjtn000.setLabel(leaf.image);
        jj_consume_token(LB);
      lb = true;
        stmtsep(jjtn000);
        label_32:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case configkeyword:
          case defaultkeyword:
          case descriptionkeyword:
          case iffeaturekeyword:
          case mandatorykeyword:
          case mustkeyword:
          case referencekeyword:
          case statuskeyword:
          case typekeyword:
          case unitskeyword:
          case whenkeyword:
            ;
            break;
          default:
            jj_la1[68] = jj_gen;
            break label_32;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case whenkeyword:
            w = whenstmt();
            stmtsep(jjtn000);
      jjtn000.setWhen(w);
            break;
          case iffeaturekeyword:
            iff = iffeaturestmt();
            stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
            break;
          case typekeyword:
            t = typestmt();
            stmtsep(jjtn000);
      jjtn000.setType(t);
            break;
          case unitskeyword:
            u = unitsstmt();
            stmtsep(jjtn000);
      jjtn000.setUnits(u);
            break;
          case mustkeyword:
            m = muststmt();
            stmtsep(jjtn000);
      jjtn000.addMust(m);
            break;
          case defaultkeyword:
            d = defaultstmt();
            stmtsep(jjtn000);
      jjtn000.setDefault(d);
            break;
          case configkeyword:
            c = configstmt();
            stmtsep(jjtn000);
      jjtn000.setConfig(c);
            break;
          case mandatorykeyword:
            ma = mandatorystmt();
            stmtsep(jjtn000);
      jjtn000.setMandatory(ma);
            break;
          case statuskeyword:
            s = statusstmt();
            stmtsep(jjtn000);
      jjtn000.setStatus(s);
            break;
          case descriptionkeyword:
            de = descriptionstmt();
            stmtsep(jjtn000);
      jjtn000.setDescription(de);
            break;
          case referencekeyword:
            r = referencestmt();
            stmtsep(jjtn000);
      jjtn000.setReference(r);
            break;
          default:
            jj_la1[69] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(RB);
      {if (true) return jjtn000;}
      } catch (ParseException pe) {
    if (lb) skip_to(RB);
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_LeafList leafliststmt() throws ParseException {
 /*@bgen(jjtree) LeafList */
  YANG_LeafList jjtn000 = new YANG_LeafList(JJTLEAFLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token leaflist;
  boolean lb = false;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Type t = null;
  YANG_Units u = null;
  YANG_Must mu = null;
  YANG_Config c = null;
  YANG_MinElement mi = null;
  YANG_MaxElement ma = null;
  YANG_OrderedBy o = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        leaflist = jj_consume_token(leaflistkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(leaflist.beginLine);
      jjtn000.setCol(leaflist.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLeafList(i);
      jjtn000.setLabel(leaflist.image);
        jj_consume_token(LB);
      lb = true;
        stmtsep(jjtn000);
        label_33:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case configkeyword:
          case descriptionkeyword:
          case iffeaturekeyword:
          case maxelementskeyword:
          case minelementskeyword:
          case mustkeyword:
          case orderedbykeyword:
          case referencekeyword:
          case statuskeyword:
          case typekeyword:
          case unitskeyword:
          case whenkeyword:
            ;
            break;
          default:
            jj_la1[70] = jj_gen;
            break label_33;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case whenkeyword:
            w = whenstmt();
            stmtsep(jjtn000);
      jjtn000.setWhen(w);
            break;
          case iffeaturekeyword:
            iff = iffeaturestmt();
            stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
            break;
          case typekeyword:
            t = typestmt();
            stmtsep(jjtn000);
      jjtn000.setType(t);
            break;
          case unitskeyword:
            u = unitsstmt();
            stmtsep(jjtn000);
      jjtn000.setUnits(u);
            break;
          case mustkeyword:
            mu = muststmt();
            stmtsep(jjtn000);
      jjtn000.addMust(mu);
            break;
          case configkeyword:
            c = configstmt();
            stmtsep(jjtn000);
      jjtn000.setConfig(c);
            break;
          case minelementskeyword:
            mi = minelementsstmt();
            stmtsep(jjtn000);
      jjtn000.setMinElement(mi);
            break;
          case maxelementskeyword:
            ma = maxelementsstmt();
            stmtsep(jjtn000);
      jjtn000.setMaxElement(ma);
            break;
          case orderedbykeyword:
            o = orderedbystmt();
            stmtsep(jjtn000);
      jjtn000.setOrderedBy(o);
            break;
          case statuskeyword:
            s = statusstmt();
            stmtsep(jjtn000);
      jjtn000.setStatus(s);
            break;
          case descriptionkeyword:
            d = descriptionstmt();
            stmtsep(jjtn000);
      jjtn000.setDescription(d);
            break;
          case referencekeyword:
            r = referencestmt();
            stmtsep(jjtn000);
      jjtn000.setReference(r);
            break;
          default:
            jj_la1[71] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(RB);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_List liststmt() throws ParseException {
 /*@bgen(jjtree) List */
  YANG_List jjtn000 = new YANG_List(JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token list;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Must m = null;
  YANG_Key k = null;
  YANG_Unique u = null;
  YANG_Config c = null;
  YANG_MinElement mi = null;
  YANG_MaxElement ma = null;
  YANG_OrderedBy o = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef dd = null;
    try {
      try {
        list = jj_consume_token(listkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(list.beginLine);
      jjtn000.setCol(list.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setList(i);
      jjtn000.setLabel(list.image);
        jj_consume_token(LB);
      lb = true;
        stmtsep(jjtn000);
        label_34:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case anyxmlkeyword:
          case choicekeyword:
          case configkeyword:
          case containerkeyword:
          case descriptionkeyword:
          case groupingkeyword:
          case iffeaturekeyword:
          case keykeyword:
          case leafkeyword:
          case leaflistkeyword:
          case listkeyword:
          case maxelementskeyword:
          case minelementskeyword:
          case mustkeyword:
          case orderedbykeyword:
          case referencekeyword:
          case statuskeyword:
          case typedefkeyword:
          case uniquekeyword:
          case useskeyword:
          case whenkeyword:
            ;
            break;
          default:
            jj_la1[72] = jj_gen;
            break label_34;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case whenkeyword:
            w = whenstmt();
            stmtsep(jjtn000);
      jjtn000.setWhen(w);
            break;
          case iffeaturekeyword:
            iff = iffeaturestmt();
            stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
            break;
          case mustkeyword:
            m = muststmt();
            stmtsep(jjtn000);
      jjtn000.addMust(m);
            break;
          case keykeyword:
            k = keystmt();
            stmtsep(jjtn000);
      jjtn000.setKey(k);
            break;
          case uniquekeyword:
            u = uniquestmt();
            stmtsep(jjtn000);
      jjtn000.addUnique(u);
            break;
          case configkeyword:
            c = configstmt();
            stmtsep(jjtn000);
      jjtn000.setConfig(c);
            break;
          case minelementskeyword:
            mi = minelementsstmt();
            stmtsep(jjtn000);
      jjtn000.setMinElement(mi);
            break;
          case maxelementskeyword:
            ma = maxelementsstmt();
            stmtsep(jjtn000);
      jjtn000.setMaxElement(ma);
            break;
          case orderedbykeyword:
            o = orderedbystmt();
            stmtsep(jjtn000);
      jjtn000.setOrderedBy(o);
            break;
          case statuskeyword:
            s = statusstmt();
            stmtsep(jjtn000);
      jjtn000.setStatus(s);
            break;
          case descriptionkeyword:
            d = descriptionstmt();
            stmtsep(jjtn000);
      jjtn000.setDescription(d);
            break;
          case referencekeyword:
            r = referencestmt();
            stmtsep(jjtn000);
      jjtn000.setReference(r);
            break;
          case typedefkeyword:
            t = typedefstmt();
            stmtsep(jjtn000);
      jjtn000.addTypeDef(t);
            break;
          case groupingkeyword:
            g = groupingstmt();
            stmtsep(jjtn000);
      jjtn000.addGrouping((YANG_Grouping) g);
            break;
          case anyxmlkeyword:
          case choicekeyword:
          case containerkeyword:
          case leafkeyword:
          case leaflistkeyword:
          case listkeyword:
          case useskeyword:
            dd = datadefstmt();
            stmtsep(jjtn000);
      jjtn000.addDataDef(dd);
            break;
          default:
            jj_la1[73] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(RB);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Key keystmt() throws ParseException {
 /*@bgen(jjtree) Key */
  YANG_Key jjtn000 = new YANG_Key(JJTKEY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token key;
  String k = null;
    try {
      try {
        key = jj_consume_token(keykeyword);
        sep();
        k = keyargstr();
        stmtend(jjtn000);
      jjtn000.setLine(key.beginLine);
      jjtn000.setCol(key.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setKey(k);
      jjtn000.setLabel(key.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String keyargstr() throws ParseException {
  String k = null;
    //< a string which matches the rule
      //   keyarg >
      k = stringoroneword();
    {if (true) return k;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Unique uniquestmt() throws ParseException {
 /*@bgen(jjtree) Unique */
  YANG_Unique jjtn000 = new YANG_Unique(JJTUNIQUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token unique;
  String u = null;
    try {
      try {
        unique = jj_consume_token(uniquekeyword);
        sep();
        u = uniqueargstr();
        stmtend(jjtn000);
      jjtn000.setLine(unique.beginLine);
      jjtn000.setCol(unique.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setUnique(u);
      jjtn000.setLabel(unique.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String uniqueargstr() throws ParseException {
  String u = null;
    //	< a string which matches the rule
      //           uniquearg >
      u = stringoroneword();
    {if (true) return u;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Choice choicestmt() throws ParseException {
 /*@bgen(jjtree) Choice */
  YANG_Choice jjtn000 = new YANG_Choice(JJTCHOICE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token choice;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Default d = null;
  YANG_Config cf = null;
  YANG_Mandatory m = null;
  YANG_Status s = null;
  YANG_Description de = null;
  YANG_Reference r = null;
  YANG_ShortCase sc = null;
  YANG_Case c = null;
    try {
      try {
        choice = jj_consume_token(choicekeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(choice.beginLine);
      jjtn000.setCol(choice.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setChoice(i);
      jjtn000.setLabel(choice.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_35:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case anyxmlkeyword:
            case casekeyword:
            case configkeyword:
            case containerkeyword:
            case defaultkeyword:
            case descriptionkeyword:
            case iffeaturekeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case mandatorykeyword:
            case referencekeyword:
            case statuskeyword:
            case whenkeyword:
              ;
              break;
            default:
              jj_la1[74] = jj_gen;
              break label_35;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case whenkeyword:
              w = whenstmt();
              stmtsep(jjtn000);
      jjtn000.setWhen(w);
              break;
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case defaultkeyword:
              d = defaultstmt();
              stmtsep(jjtn000);
      jjtn000.setDefault(d);
              break;
            case configkeyword:
              cf = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(cf);
              break;
            case mandatorykeyword:
              m = mandatorystmt();
              stmtsep(jjtn000);
      jjtn000.setMandatory(m);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              de = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(de);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case anyxmlkeyword:
            case containerkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
              sc = shortcasestmt();
              stmtsep(jjtn000);
      jjtn000.addShortCase(sc);
              break;
            case casekeyword:
              c = casestmt();
              stmtsep(jjtn000);
      jjtn000.addCase(c);
              break;
            default:
              jj_la1[75] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_ShortCase shortcasestmt() throws ParseException {
  YANG_ShortCase d = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case containerkeyword:
      d = containerstmt();
      break;
    case leafkeyword:
      d = leafstmt();
      break;
    case leaflistkeyword:
      d = leafliststmt();
      break;
    case listkeyword:
      d = liststmt();
      break;
    case anyxmlkeyword:
      d = anyxmlstmt();
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return d;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Case casestmt() throws ParseException {
 /*@bgen(jjtree) Case */
  YANG_Case jjtn000 = new YANG_Case(JJTCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token tcase;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_DataDef c = null;
    try {
      try {
        tcase = jj_consume_token(casekeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(tcase.beginLine);
      jjtn000.setCol(tcase.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setCase(i);
      jjtn000.setLabel(tcase.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_36:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case descriptionkeyword:
            case iffeaturekeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case referencekeyword:
            case statuskeyword:
            case useskeyword:
            case whenkeyword:
              ;
              break;
            default:
              jj_la1[78] = jj_gen;
              break label_36;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case whenkeyword:
              w = whenstmt();
              stmtsep(jjtn000);
      jjtn000.setWhen(w);
              break;
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case useskeyword:
              c = datadefstmt();
              stmtsep(jjtn000);
      jjtn000.addDataDef(c);
              break;
            default:
              jj_la1[79] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_AnyXml anyxmlstmt() throws ParseException {
 /*@bgen(jjtree) AnyXml */
  YANG_AnyXml jjtn000 = new YANG_AnyXml(JJTANYXML);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token any;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Must mu = null;
  YANG_Config c = null;
  YANG_Mandatory m = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        any = jj_consume_token(anyxmlkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(any.beginLine);
      jjtn000.setCol(any.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setAnyXml(i);
      jjtn000.setLabel(any.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_37:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case configkeyword:
            case descriptionkeyword:
            case iffeaturekeyword:
            case mandatorykeyword:
            case mustkeyword:
            case referencekeyword:
            case statuskeyword:
            case whenkeyword:
              ;
              break;
            default:
              jj_la1[81] = jj_gen;
              break label_37;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case whenkeyword:
              w = whenstmt();
              stmtsep(jjtn000);
      jjtn000.setWhen(w);
              break;
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case mustkeyword:
              mu = muststmt();
              stmtsep(jjtn000);
      jjtn000.addMust(mu);
              break;
            case configkeyword:
              c = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(c);
              break;
            case mandatorykeyword:
              m = mandatorystmt();
              stmtsep(jjtn000);
      jjtn000.setMandatory(m);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[82] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[83] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Uses usesstmt() throws ParseException {
 /*@bgen(jjtree) Uses */
  YANG_Uses jjtn000 = new YANG_Uses(JJTUSES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token uses;
  String i = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_RefineAnyNode re = null;
  YANG_UsesAugment u = null;
    try {
      try {
        uses = jj_consume_token(useskeyword);
        sep();
        i = identifierrefargstr();
        optsep();
      jjtn000.setLine(uses.beginLine);
      jjtn000.setCol(uses.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setUses(i);
      jjtn000.setLabel(uses.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_38:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case augmentkeyword:
            case descriptionkeyword:
            case iffeaturekeyword:
            case referencekeyword:
            case refinekeyword:
            case statuskeyword:
            case whenkeyword:
              ;
              break;
            default:
              jj_la1[84] = jj_gen;
              break label_38;
            }
            if (jj_2_13(3)) {
              w = whenstmt();
              stmtsep(jjtn000);
      jjtn000.setWhen(w);
            } else if (jj_2_14(3)) {
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
            } else if (jj_2_15(3)) {
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
            } else if (jj_2_16(3)) {
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
            } else if (jj_2_17(3)) {
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case refinekeyword:
                re = refinementstmt();
                stmtsep(jjtn000);
      jjtn000.addRefinement(re);
                break;
              case augmentkeyword:
                u = usesaugmentstmt();
                stmtsep(jjtn000);
      jjtn000.addUsesAugment(u);
                break;
              default:
                jj_la1[85] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineAnyNode refinementstmt() throws ParseException {
 /*@bgen(jjtree) RefineAnyNode */
  YANG_RefineAnyNode jjtn000 = new YANG_RefineAnyNode(JJTREFINEANYNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  YANG_Must m = null;
  YANG_Presence pr = null;
  YANG_Config c = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_Default dt = null;
  YANG_Mandatory ma = null;
  YANG_MinElement mi = null;
  YANG_MaxElement max = null;
  Token t;
  String i = null;
    try {
      try {
        t = jj_consume_token(refinekeyword);
        sep();
        i = refineargstr();
        optsep();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_39:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case configkeyword:
            case defaultkeyword:
            case descriptionkeyword:
            case mandatorykeyword:
            case maxelementskeyword:
            case minelementskeyword:
            case mustkeyword:
            case presencekeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[87] = jj_gen;
              break label_39;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case mustkeyword:
              m = muststmt();
              stmtsep(jjtn000);
      jjtn000.addMust(m);
              break;
            case presencekeyword:
              pr = presencestmt();
              stmtsep(jjtn000);
      jjtn000.setPresence(pr);
              break;
            case configkeyword:
              c = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(c);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case defaultkeyword:
              dt = defaultstmt();
              stmtsep(jjtn000);
      jjtn000.setDefault(dt);
              break;
            case mandatorykeyword:
              ma = mandatorystmt();
              stmtsep(jjtn000);
      jjtn000.setMandatory(ma);
              break;
            case minelementskeyword:
              mi = minelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMinElement(mi);
              break;
            case maxelementskeyword:
              max = maxelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMaxElement(max);
              break;
            default:
              jj_la1[88] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[89] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtn000.setFileName(filename);
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setRefineAnyNodeId(i);
      jjtn000.setLabel(t.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String refineargstr() throws ParseException {
  String r = null;
    r = stringoroneword();
    {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineContainer refinecontainerstmt() throws ParseException {
 /*@bgen(jjtree) RefineContainer */
  YANG_RefineContainer jjtn000 = new YANG_RefineContainer(JJTREFINECONTAINER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Must m = null;
  YANG_Presence p = null;
  YANG_Config c = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case configkeyword:
        case descriptionkeyword:
        case mustkeyword:
        case presencekeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[90] = jj_gen;
          break label_40;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mustkeyword:
          m = muststmt();
          stmtsep(jjtn000);
      jjtn000.addMust(m);
          break;
        case presencekeyword:
          p = presencestmt();
          stmtsep(jjtn000);
      jjtn000.setPresence(p);
          break;
        case configkeyword:
          c = configstmt();
          stmtsep(jjtn000);
      jjtn000.setConfig(c);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineLeaf refineleafstmt() throws ParseException {
 /*@bgen(jjtree) RefineLeaf */
  YANG_RefineLeaf jjtn000 = new YANG_RefineLeaf(JJTREFINELEAF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);YANG_Must m = null;
  YANG_Default d = null;
  YANG_Config c = null;
  YANG_Mandatory ma = null;
  YANG_Description de = null;
  YANG_Reference r = null;
    try {
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case configkeyword:
        case defaultkeyword:
        case descriptionkeyword:
        case mandatorykeyword:
        case mustkeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[92] = jj_gen;
          break label_41;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mustkeyword:
          m = muststmt();
          stmtsep(jjtn000);
      jjtn000.addMust(m);
          break;
        case defaultkeyword:
          d = defaultstmt();
          stmtsep(jjtn000);
      jjtn000.setDefault(d);
          break;
        case configkeyword:
          c = configstmt();
          stmtsep(jjtn000);
      jjtn000.setConfig(c);
          break;
        case mandatorykeyword:
          ma = mandatorystmt();
          stmtsep(jjtn000);
      jjtn000.setMandatory(ma);
          break;
        case descriptionkeyword:
          de = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(de);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[93] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineLeafList refineleafliststmt() throws ParseException {
 /*@bgen(jjtree) RefineLeafList */
  YANG_RefineLeafList jjtn000 = new YANG_RefineLeafList(JJTREFINELEAFLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String i = null;
  YANG_Must m = null;
  YANG_Config c = null;
  YANG_MinElement mi = null;
  YANG_MaxElement ma = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t;
    try {
      label_42:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case configkeyword:
        case descriptionkeyword:
        case maxelementskeyword:
        case minelementskeyword:
        case mustkeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[94] = jj_gen;
          break label_42;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mustkeyword:
          m = muststmt();
          stmtsep(jjtn000);
      jjtn000.addMust(m);
          break;
        case configkeyword:
          c = configstmt();
          stmtsep(jjtn000);
      jjtn000.setConfig(c);
          break;
        case minelementskeyword:
          mi = minelementsstmt();
          stmtsep(jjtn000);
      jjtn000.setMinElement(mi);
          break;
        case maxelementskeyword:
          ma = maxelementsstmt();
          stmtsep(jjtn000);
      jjtn000.setMaxElement(ma);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineList refineliststmt() throws ParseException {
 /*@bgen(jjtree) RefineList */
  YANG_RefineList jjtn000 = new YANG_RefineList(JJTREFINELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String i = null;
  YANG_Must m = null;
  YANG_Config c = null;
  YANG_MinElement mi = null;
  YANG_MaxElement ma = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t;
    try {
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case configkeyword:
        case descriptionkeyword:
        case maxelementskeyword:
        case minelementskeyword:
        case mustkeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[96] = jj_gen;
          break label_43;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case mustkeyword:
          m = muststmt();
          stmtsep(jjtn000);
      jjtn000.addMust(m);
          break;
        case configkeyword:
          c = configstmt();
          stmtsep(jjtn000);
      jjtn000.setConfig(c);
          break;
        case minelementskeyword:
          mi = minelementsstmt();
          stmtsep(jjtn000);
      jjtn000.setMinElement(mi);
          break;
        case maxelementskeyword:
          ma = maxelementsstmt();
          stmtsep(jjtn000);
      jjtn000.setMaxElement(ma);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[97] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineChoice refinechoicestmt() throws ParseException {
 /*@bgen(jjtree) RefineChoice */
  YANG_RefineChoice jjtn000 = new YANG_RefineChoice(JJTREFINECHOICE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String i = null;
  YANG_Default d = null;
  YANG_Config c = null;
  YANG_Mandatory m = null;
  YANG_Description de = null;
  YANG_Reference r = null;
  Token t;
    try {
      label_44:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case configkeyword:
        case defaultkeyword:
        case descriptionkeyword:
        case mandatorykeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[98] = jj_gen;
          break label_44;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case defaultkeyword:
          d = defaultstmt();
          stmtsep(jjtn000);
      jjtn000.setDefault(d);
          break;
        case configkeyword:
          c = configstmt();
          stmtsep(jjtn000);
      jjtn000.setConfig(c);
          break;
        case mandatorykeyword:
          m = mandatorystmt();
          stmtsep(jjtn000);
      jjtn000.setMandatory(m);
          break;
        case descriptionkeyword:
          de = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(de);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        default:
          jj_la1[99] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineCase refinecasestmt() throws ParseException {
 /*@bgen(jjtree) RefineCase */
  YANG_RefineCase jjtn000 = new YANG_RefineCase(JJTREFINECASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String i = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case descriptionkeyword:
        d = descriptionstmt();
        stmtsep(jjtn000);
      jjtn000.setDescription(d);
        break;
      case referencekeyword:
        r = referencestmt();
        stmtsep(jjtn000);
      jjtn000.setReference(r);
        break;
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_RefineAnyXml refineanyxmlstmt() throws ParseException {
 /*@bgen(jjtree) RefineAnyXml */
  YANG_RefineAnyXml jjtn000 = new YANG_RefineAnyXml(JJTREFINEANYXML);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String i = null;
  YANG_Config c = null;
  YANG_Mandatory m = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_Must mu = null;
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case mustkeyword:
        mu = muststmt();
        stmtsep(jjtn000);
      jjtn000.addMust(mu);
        c = configstmt();
        stmtsep(jjtn000);
      jjtn000.setConfig(c);
        break;
      case mandatorykeyword:
        m = mandatorystmt();
        stmtsep(jjtn000);
      jjtn000.setMandatory(m);
        break;
      case descriptionkeyword:
        d = descriptionstmt();
        stmtsep(jjtn000);
      jjtn000.setDescription(d);
        break;
      case referencekeyword:
        r = referencestmt();
        stmtsep(jjtn000);
      jjtn000.setReference(r);
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setFileName(filename);
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_UsesAugment usesaugmentstmt() throws ParseException {
 /*@bgen(jjtree) UsesAugment */
  YANG_UsesAugment jjtn000 = new YANG_UsesAugment(JJTUSESAUGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token aug, aa;
  String ds = null;
  String a = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_DataDef da = null;
  YANG_Case c = null;
    try {
      aug = jj_consume_token(augmentkeyword);
      sep();
      a = usesaugmentargstr();
      optsep();
    jjtn000.setLine(aug.beginLine);
    jjtn000.setCol(aug.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setUsesAugment(a);
    jjtn000.setLabel(aug.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_45:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case casekeyword:
        case choicekeyword:
        case containerkeyword:
        case descriptionkeyword:
        case iffeaturekeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case referencekeyword:
        case statuskeyword:
        case useskeyword:
        case whenkeyword:
          ;
          break;
        default:
          jj_la1[102] = jj_gen;
          break label_45;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case whenkeyword:
          w = whenstmt();
          stmtsep(jjtn000);
      jjtn000.setWhen(w);
          break;
        case iffeaturekeyword:
          iff = iffeaturestmt();
          stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
          break;
        case statuskeyword:
          s = statusstmt();
          stmtsep(jjtn000);
      jjtn000.setStatus(s);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        case anyxmlkeyword:
        case casekeyword:
        case choicekeyword:
        case containerkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case useskeyword:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case anyxmlkeyword:
          case choicekeyword:
          case containerkeyword:
          case leafkeyword:
          case leaflistkeyword:
          case listkeyword:
          case useskeyword:
            da = datadefstmt();
            stmtsep(jjtn000);
        jjtn000.addDataDef(da);
            break;
          case casekeyword:
            c = casestmt();
            stmtsep(jjtn000);
        jjtn000.addCase(c);
            break;
          default:
            jj_la1[103] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String usesaugmentargstr() throws ParseException {
  String s = null;
    s = stringoroneword();
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Augment augmentstmt() throws ParseException {
 /*@bgen(jjtree) Augment */
  YANG_Augment jjtn000 = new YANG_Augment(JJTAUGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token aug, aa;
  String a = null;
  YANG_When w = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_DataDef da = null;
  YANG_Case c = null;
  YANG_Input i = null;
  YANG_Output o = null;
    try {
      aug = jj_consume_token(augmentkeyword);
      sep();
      a = augmentargstr();
      optsep();
    jjtn000.setLine(aug.beginLine);
    jjtn000.setCol(aug.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setAugment(a);
    jjtn000.setLabel(aug.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_46:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case casekeyword:
        case choicekeyword:
        case containerkeyword:
        case descriptionkeyword:
        case iffeaturekeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case referencekeyword:
        case statuskeyword:
        case useskeyword:
        case whenkeyword:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_46;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case whenkeyword:
          w = whenstmt();
          stmtsep(jjtn000);
      jjtn000.setWhen(w);
          break;
        case iffeaturekeyword:
          iff = iffeaturestmt();
          stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
          break;
        case statuskeyword:
          s = statusstmt();
          stmtsep(jjtn000);
      jjtn000.setStatus(s);
          break;
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        case anyxmlkeyword:
        case casekeyword:
        case choicekeyword:
        case containerkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case useskeyword:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case anyxmlkeyword:
          case choicekeyword:
          case containerkeyword:
          case leafkeyword:
          case leaflistkeyword:
          case listkeyword:
          case useskeyword:
            da = datadefstmt();
            stmtsep(jjtn000);
        jjtn000.addDataDef(da);
            break;
          case casekeyword:
            c = casestmt();
            stmtsep(jjtn000);
        jjtn000.addCase(c);
            break;
          default:
            jj_la1[106] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[107] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String augmentargstr() throws ParseException {
  String a = null;
    a = stringoroneword();
    {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Unknown unknownstatement() throws ParseException {
 /*@bgen(jjtree) Unknown */
  YANG_Unknown jjtn000 = new YANG_Unknown(JJTUNKNOWN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String p = null;
  String i = null, str = "";
  Token s;
  YANG_Unknown unknown = null;
    try {
      s = jj_consume_token(P);
      jjtn000.setExtension(s.image);
      jjtn000.setLabel(s.image);
      if (jj_2_18(2)) {
        sep();
        str = stringoroneword();
        jjtn000.setArgument(str);
      } else {
        ;
      }
      optsep();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC:
        jj_consume_token(SC);
        break;
      case LB:
        jj_consume_token(LB);
        optsep();
        label_47:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CMT:
          case WSP:
          case CRLF:
          case anyxmlkeyword:
          case argumentkeyword:
          case augmentkeyword:
          case basekeyword:
          case belongstokeyword:
          case bitkeyword:
          case casekeyword:
          case choicekeyword:
          case configkeyword:
          case contactkeyword:
          case containerkeyword:
          case defaultkeyword:
          case descriptionkeyword:
          case enumkeyword:
          case errorapptagkeyword:
          case errormessagekeyword:
          case extensionkeyword:
          case deviationkeyword:
          case deviatekeyword:
          case featurekeyword:
          case fractiondigitskeyword:
          case groupingkeyword:
          case identitykeyword:
          case iffeaturekeyword:
          case importkeyword:
          case includekeyword:
          case inputkeyword:
          case keykeyword:
          case leafkeyword:
          case leaflistkeyword:
          case lengthkeyword:
          case listkeyword:
          case mandatorykeyword:
          case maxelementskeyword:
          case minelementskeyword:
          case modulekeyword:
          case mustkeyword:
          case namespacekeyword:
          case notificationkeyword:
          case orderedbykeyword:
          case organizationkeyword:
          case outputkeyword:
          case pathkeyword:
          case patternkeyword:
          case positionkeyword:
          case prefixkeyword:
          case presencekeyword:
          case rangekeyword:
          case referencekeyword:
          case refinekeyword:
          case requireinstancekeyword:
          case revisionkeyword:
          case rpckeyword:
          case statuskeyword:
          case submodulekeyword:
          case typekeyword:
          case typedefkeyword:
          case uniquekeyword:
          case unitskeyword:
          case useskeyword:
          case valuekeyword:
          case whenkeyword:
          case yangversionkeyword:
          case yinelementkeyword:
          case addkeyword:
          case currentkeyword:
          case deprecatedkeyword:
          case deletekeyword:
          case falsekeyword:
          case minkeyword:
          case maxkeyword:
          case nankeyword:
          case neginfkeyword:
          case notsupportedkeyword:
          case obsoletekeyword:
          case posinfkeyword:
          case replacekeyword:
          case systemkeyword:
          case truekeyword:
          case unboundedkeyword:
          case userkeyword:
          case P:
          case S:
            ;
            break;
          default:
            jj_la1[108] = jj_gen;
            break label_47;
          }
          unknown = unknownstatement2();
          optsep();
          jjtn000.addUnknown(unknown);
        }
        jj_consume_token(RB);
        optsep();
        break;
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Unknown unknownstatement2() throws ParseException {
 /*@bgen(jjtree) Unknown */
  YANG_Unknown jjtn000 = new YANG_Unknown(JJTUNKNOWN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String a = null, i = null, str = "";
  Token dp = null, s;
  YANG_Unknown unknown = null;
    try {
      optsep();
      if (jj_2_21(2)) {
        if (jj_2_19(2)) {
          s = jj_consume_token(S);
        } else if (jj_2_20(2)) {
          s = jj_consume_token(P);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        jjtn000.setExtension(s.image);
        jjtn000.setLabel(s.image);
      } else if (jj_2_22(2)) {
        a = anykeyword();
          jjtn000.setExtension(a);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_23(2)) {
        sep();
        str = stringoroneword();
        jjtn000.setArgument(str);
      } else {
        ;
      }
      optsep();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SC:
        jj_consume_token(SC);
        break;
      case LB:
        jj_consume_token(LB);
        optsep();
        label_48:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CMT:
          case WSP:
          case CRLF:
          case anyxmlkeyword:
          case argumentkeyword:
          case augmentkeyword:
          case basekeyword:
          case belongstokeyword:
          case bitkeyword:
          case casekeyword:
          case choicekeyword:
          case configkeyword:
          case contactkeyword:
          case containerkeyword:
          case defaultkeyword:
          case descriptionkeyword:
          case enumkeyword:
          case errorapptagkeyword:
          case errormessagekeyword:
          case extensionkeyword:
          case deviationkeyword:
          case deviatekeyword:
          case featurekeyword:
          case fractiondigitskeyword:
          case groupingkeyword:
          case identitykeyword:
          case iffeaturekeyword:
          case importkeyword:
          case includekeyword:
          case inputkeyword:
          case keykeyword:
          case leafkeyword:
          case leaflistkeyword:
          case lengthkeyword:
          case listkeyword:
          case mandatorykeyword:
          case maxelementskeyword:
          case minelementskeyword:
          case modulekeyword:
          case mustkeyword:
          case namespacekeyword:
          case notificationkeyword:
          case orderedbykeyword:
          case organizationkeyword:
          case outputkeyword:
          case pathkeyword:
          case patternkeyword:
          case positionkeyword:
          case prefixkeyword:
          case presencekeyword:
          case rangekeyword:
          case referencekeyword:
          case refinekeyword:
          case requireinstancekeyword:
          case revisionkeyword:
          case rpckeyword:
          case statuskeyword:
          case submodulekeyword:
          case typekeyword:
          case typedefkeyword:
          case uniquekeyword:
          case unitskeyword:
          case useskeyword:
          case valuekeyword:
          case whenkeyword:
          case yangversionkeyword:
          case yinelementkeyword:
          case addkeyword:
          case currentkeyword:
          case deprecatedkeyword:
          case deletekeyword:
          case falsekeyword:
          case minkeyword:
          case maxkeyword:
          case nankeyword:
          case neginfkeyword:
          case notsupportedkeyword:
          case obsoletekeyword:
          case posinfkeyword:
          case replacekeyword:
          case systemkeyword:
          case truekeyword:
          case unboundedkeyword:
          case userkeyword:
          case P:
          case S:
            ;
            break;
          default:
            jj_la1[110] = jj_gen;
            break label_48;
          }
          unknown = unknownstatement2();
          optsep();
          jjtn000.addUnknown(unknown);
        }
        jj_consume_token(RB);
        optsep();
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_When whenstmt() throws ParseException {
 /*@bgen(jjtree) When */
  YANG_When jjtn000 = new YANG_When(JJTWHEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token when;
  String w = null;
  YANG_Description d = null;
  YANG_Reference r = null;
    try {
      try {
        when = jj_consume_token(whenkeyword);
        sep();
        w = string();
        optsep();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_49:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case referencekeyword:
              ;
              break;
            default:
              jj_la1[112] = jj_gen;
              break label_49;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            default:
              jj_la1[113] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[114] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtn000.setLine(when.beginLine);
      jjtn000.setCol(when.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setWhen(w);
      jjtn000.setLabel(when.image);
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Rpc rpcstmt() throws ParseException {
 /*@bgen(jjtree) Rpc */
  YANG_Rpc jjtn000 = new YANG_Rpc(JJTRPC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token to;
  String i = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_Input in = null;
  YANG_Output o = null;
    try {
      try {
        to = jj_consume_token(rpckeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(to.beginLine);
      jjtn000.setCol(to.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setRpc(i);
      jjtn000.setLabel(to.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_50:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case descriptionkeyword:
            case groupingkeyword:
            case iffeaturekeyword:
            case inputkeyword:
            case outputkeyword:
            case referencekeyword:
            case statuskeyword:
            case typedefkeyword:
              ;
              break;
            default:
              jj_la1[115] = jj_gen;
              break label_50;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case groupingkeyword:
            case typedefkeyword:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case typedefkeyword:
                t = typedefstmt();
      jjtn000.addTypeDef(t);
                break;
              case groupingkeyword:
                g = groupingstmt();
      jjtn000.addGrouping((YANG_Grouping) g);
                break;
              default:
                jj_la1[116] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              stmtsep(jjtn000);
              break;
            case inputkeyword:
              in = inputstmt();
              stmtsep(jjtn000);
      jjtn000.setInput(in);
              break;
            case outputkeyword:
              o = outputstmt();
              stmtsep(jjtn000);
      jjtn000.setOutput(o);
              break;
            default:
              jj_la1[117] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[118] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Input inputstmt() throws ParseException {
 /*@bgen(jjtree) Input */
  YANG_Input jjtn000 = new YANG_Input(JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token to;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef d = null;
    try {
      to = jj_consume_token(inputkeyword);
      optsep();
    jjtn000.setLine(to.beginLine);
    jjtn000.setCol(to.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setLabel(to.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_51:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case choicekeyword:
        case containerkeyword:
        case groupingkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case typedefkeyword:
        case useskeyword:
          ;
          break;
        default:
          jj_la1[119] = jj_gen;
          break label_51;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case groupingkeyword:
        case typedefkeyword:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case typedefkeyword:
            t = typedefstmt();
        jjtn000.addTypeDef(t);
            break;
          case groupingkeyword:
            g = groupingstmt();
        jjtn000.addGrouping((YANG_Grouping) g);
            break;
          default:
            jj_la1[120] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          stmtsep(jjtn000);
          break;
        case anyxmlkeyword:
        case choicekeyword:
        case containerkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case useskeyword:
          label_52:
          while (true) {
            d = datadefstmt();
            stmtsep(jjtn000);
        jjtn000.addDataDef(d);
            if (jj_2_24(2)) {
              ;
            } else {
              break label_52;
            }
          }
          break;
        default:
          jj_la1[121] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Output outputstmt() throws ParseException {
 /*@bgen(jjtree) Output */
  YANG_Output jjtn000 = new YANG_Output(JJTOUTPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token to;
  String i = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef d = null;
    try {
      to = jj_consume_token(outputkeyword);
      optsep();
    jjtn000.setLine(to.beginLine);
    jjtn000.setCol(to.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setLabel(to.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_53:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case anyxmlkeyword:
        case choicekeyword:
        case containerkeyword:
        case groupingkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case typedefkeyword:
        case useskeyword:
          ;
          break;
        default:
          jj_la1[122] = jj_gen;
          break label_53;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case groupingkeyword:
        case typedefkeyword:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case typedefkeyword:
            t = typedefstmt();
        jjtn000.addTypeDef(t);
            break;
          case groupingkeyword:
            g = groupingstmt();
        jjtn000.addGrouping((YANG_Grouping) g);
            break;
          default:
            jj_la1[123] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          stmtsep(jjtn000);
          break;
        case anyxmlkeyword:
        case choicekeyword:
        case containerkeyword:
        case leafkeyword:
        case leaflistkeyword:
        case listkeyword:
        case useskeyword:
          label_54:
          while (true) {
            d = datadefstmt();
            stmtsep(jjtn000);
            if (jj_2_25(2)) {
              ;
            } else {
              break label_54;
            }
          }
      jjtn000.addDataDef(d);
          break;
        default:
          jj_la1[124] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Notification notificationstmt() throws ParseException {
 /*@bgen(jjtree) Notification */
  YANG_Notification jjtn000 = new YANG_Notification(JJTNOTIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token to;
  String i = null;
  YANG_IfFeature iff = null;
  YANG_Status s = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_TypeDef t = null;
  YANG_Body g = null;
  YANG_DataDef da = null;
    try {
      try {
        to = jj_consume_token(notificationkeyword);
        sep();
        i = identifierargstr();
        optsep();
      jjtn000.setLine(to.beginLine);
      jjtn000.setCol(to.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setNotification(i);
      jjtn000.setLabel(to.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_55:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case descriptionkeyword:
            case groupingkeyword:
            case iffeaturekeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case referencekeyword:
            case statuskeyword:
            case typedefkeyword:
            case useskeyword:
              ;
              break;
            default:
              jj_la1[125] = jj_gen;
              break label_55;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case iffeaturekeyword:
              iff = iffeaturestmt();
              stmtsep(jjtn000);
      jjtn000.addIfFeature(iff);
              break;
            case statuskeyword:
              s = statusstmt();
              stmtsep(jjtn000);
      jjtn000.setStatus(s);
              break;
            case descriptionkeyword:
              d = descriptionstmt();
              stmtsep(jjtn000);
      jjtn000.setDescription(d);
              break;
            case referencekeyword:
              r = referencestmt();
              stmtsep(jjtn000);
      jjtn000.setReference(r);
              break;
            case groupingkeyword:
            case typedefkeyword:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case typedefkeyword:
                t = typedefstmt();
      jjtn000.addTypeDef(t);
                break;
              case groupingkeyword:
                g = groupingstmt();
      jjtn000.addGrouping((YANG_Grouping) g);
                break;
              default:
                jj_la1[126] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              stmtsep(jjtn000);
              break;
            case anyxmlkeyword:
            case choicekeyword:
            case containerkeyword:
            case leafkeyword:
            case leaflistkeyword:
            case listkeyword:
            case useskeyword:
              label_56:
              while (true) {
                da = datadefstmt();
                stmtsep(jjtn000);
                if (jj_2_26(2)) {
                  ;
                } else {
                  break label_56;
                }
              }
      jjtn000.addDataDef(da);
              break;
            default:
              jj_la1[127] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[128] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_Deviation deviationstmt() throws ParseException {
 /*@bgen(jjtree) Deviation */
  YANG_Deviation jjtn000 = new YANG_Deviation(JJTDEVIATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t, u;
  String dev = null;
  YANG_Description d = null;
  YANG_Reference r = null;
  YANG_DeviateNotSupported dns = null;
  YANG_DeviateAdd da = null;
  YANG_DeviateReplace dr = null;
  YANG_DeviateDelete dd = null;
    try {
      t = jj_consume_token(deviationkeyword);
      sep();
      dev = deviationargstr();
      optsep();
    jjtn000.setLine(t.beginLine);
    jjtn000.setCol(t.beginColumn);
    jjtn000.setFileName(filename);
    jjtn000.setDeviation(dev);
    jjtn000.setLabel(t.image);
      jj_consume_token(LB);
      stmtsep(jjtn000);
      label_57:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case descriptionkeyword:
          d = descriptionstmt();
          stmtsep(jjtn000);
      jjtn000.setDescription(d);
          break;
        case referencekeyword:
          r = referencestmt();
          stmtsep(jjtn000);
      jjtn000.setReference(r);
          break;
        case deviatekeyword:
          u = jj_consume_token(deviatekeyword);
          sep();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case notsupportedkeyword:
            dns = deviatenotsupportedstmt();
            stmtsep(jjtn000);
          jjtn000.setDeviateNotSupported(dns);
            break;
          case addkeyword:
            da = deviateaddstmt();
            stmtsep(jjtn000);
          jjtn000.addDeviateAdd(da);
            break;
          case replacekeyword:
            dr = deviatereplacestmt();
            stmtsep(jjtn000);
          jjtn000.addDeviateReplace(dr);
            break;
          case deletekeyword:
            dd = deviatedeletestmt();
            stmtsep(jjtn000);
          jjtn000.addDeviateDelete(dd);
            break;
          default:
            jj_la1[129] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[130] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case descriptionkeyword:
        case deviatekeyword:
        case referencekeyword:
          ;
          break;
        default:
          jj_la1[131] = jj_gen;
          break label_57;
        }
      }
      jj_consume_token(RB);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String deviationargstr() throws ParseException {
  String d = null;
    d = stringoroneword();
    {if (true) return d;}
    throw new Error("Missing return statement in function");
  }

  static final public YANG_DeviateNotSupported deviatenotsupportedstmt() throws ParseException {
 /*@bgen(jjtree) DeviateNotSupported */
  YANG_DeviateNotSupported jjtn000 = new YANG_DeviateNotSupported(JJTDEVIATENOTSUPPORTED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token u;
    try {
      try {
        u = jj_consume_token(notsupportedkeyword);
        optsep();
      jjtn000.setLine(u.beginLine);
      jjtn000.setCol(u.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(u.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          jj_consume_token(RB);
          break;
        default:
          jj_la1[132] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_DeviateAdd deviateaddstmt() throws ParseException {
 /*@bgen(jjtree) DeviateAdd */
  YANG_DeviateAdd jjtn000 = new YANG_DeviateAdd(JJTDEVIATEADD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token a;
  YANG_Units u = null;
  YANG_Must m = null;
  YANG_Unique uq = null;
  YANG_Default d = null;
  YANG_Config c = null;
  YANG_Mandatory ma = null;
  YANG_MinElement min = null;
  YANG_MaxElement max = null;
    try {
      try {
        a = jj_consume_token(addkeyword);
        optsep();
      jjtn000.setLine(a.beginLine);
      jjtn000.setCol(a.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(a.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_58:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case configkeyword:
            case defaultkeyword:
            case mandatorykeyword:
            case maxelementskeyword:
            case minelementskeyword:
            case mustkeyword:
            case uniquekeyword:
            case unitskeyword:
              ;
              break;
            default:
              jj_la1[133] = jj_gen;
              break label_58;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case unitskeyword:
              u = unitsstmt();
              stmtsep(jjtn000);
      jjtn000.setUnits(u);
              break;
            case mustkeyword:
              m = muststmt();
              stmtsep(jjtn000);
      jjtn000.addMust(m);
              break;
            case uniquekeyword:
              uq = uniquestmt();
              stmtsep(jjtn000);
      jjtn000.addUnique(uq);
              break;
            case defaultkeyword:
              d = defaultstmt();
              stmtsep(jjtn000);
      jjtn000.setDefault(d);
              break;
            case configkeyword:
              c = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(c);
              break;
            case mandatorykeyword:
              ma = mandatorystmt();
              stmtsep(jjtn000);
      jjtn000.setMandatory(ma);
              break;
            case minelementskeyword:
              min = minelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMinElement(min);
              break;
            case maxelementskeyword:
              max = maxelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMaxElement(max);
              break;
            default:
              jj_la1[134] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[135] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_DeviateDelete deviatedeletestmt() throws ParseException {
 /*@bgen(jjtree) DeviateDelete */
  YANG_DeviateDelete jjtn000 = new YANG_DeviateDelete(JJTDEVIATEDELETE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  YANG_Units u = null;
  YANG_Must m = null;
  YANG_Unique uq = null;
  YANG_Default d = null;
    try {
      try {
        t = jj_consume_token(deletekeyword);
        optsep();
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_59:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case defaultkeyword:
            case mustkeyword:
            case uniquekeyword:
            case unitskeyword:
              ;
              break;
            default:
              jj_la1[136] = jj_gen;
              break label_59;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case unitskeyword:
              u = unitsstmt();
              stmtsep(jjtn000);
      jjtn000.setUnits(u);
              break;
            case mustkeyword:
              m = muststmt();
              stmtsep(jjtn000);
      jjtn000.addMust(m);
              break;
            case uniquekeyword:
              uq = uniquestmt();
              stmtsep(jjtn000);
      jjtn000.setUnique(uq);
              break;
            case defaultkeyword:
              d = defaultstmt();
              stmtsep(jjtn000);
      jjtn000.setDefault(d);
              break;
            default:
              jj_la1[137] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[138] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public YANG_DeviateReplace deviatereplacestmt() throws ParseException {
 /*@bgen(jjtree) DeviateReplace */
  YANG_DeviateReplace jjtn000 = new YANG_DeviateReplace(JJTDEVIATEREPLACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);boolean lb = false;
  Token t;
  YANG_Units u = null;
  YANG_Type tp = null;
  YANG_Default d = null;
  YANG_Config c = null;
  YANG_Mandatory ma = null;
  YANG_MinElement min = null;
  YANG_MaxElement max = null;
    try {
      try {
        t = jj_consume_token(replacekeyword);
        optsep();
      jjtn000.setLine(t.beginLine);
      jjtn000.setCol(t.beginColumn);
      jjtn000.setFileName(filename);
      jjtn000.setLabel(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC:
          jj_consume_token(SC);
          break;
        case LB:
          jj_consume_token(LB);
      lb = true;
          stmtsep(jjtn000);
          label_60:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case configkeyword:
            case defaultkeyword:
            case mandatorykeyword:
            case maxelementskeyword:
            case minelementskeyword:
            case typekeyword:
            case unitskeyword:
              ;
              break;
            default:
              jj_la1[139] = jj_gen;
              break label_60;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case typekeyword:
              tp = typestmt();
              stmtsep(jjtn000);
      jjtn000.setType(tp);
              break;
            case unitskeyword:
              u = unitsstmt();
              stmtsep(jjtn000);
      jjtn000.setUnits(u);
              break;
            case defaultkeyword:
              d = defaultstmt();
              stmtsep(jjtn000);
      jjtn000.setDefault(d);
              break;
            case configkeyword:
              c = configstmt();
              stmtsep(jjtn000);
      jjtn000.setConfig(c);
              break;
            case mandatorykeyword:
              ma = mandatorystmt();
              stmtsep(jjtn000);
      jjtn000.setMandatory(ma);
              break;
            case minelementskeyword:
              min = minelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMinElement(min);
              break;
            case maxelementskeyword:
              max = maxelementsstmt();
              stmtsep(jjtn000);
      jjtn000.setMaxElement(max);
              break;
            default:
              jj_la1[140] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          jj_consume_token(RB);
          break;
        default:
          jj_la1[141] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      {if (true) return jjtn000;}
      } catch (ParseException p) {
    if (lb) skip_to(RB);
    else YangErrorManager.addError(filename, token.beginLine, token.endColumn, "token_exp", ";");
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// Ranges
  static final public String rangeargstr() throws ParseException {
  String r = null;
    //	< a string which matches the rule
      //         rangearg >
      r = stringoroneword();
    {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

// Lengths
  static final public String lengthargstr() throws ParseException {
  String l = null;
    //	< a string which matches the rule
      //         lengtharg >
      l = stringoroneword();
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

// Date  static final public String dateargstr() throws ParseException {
  String d = null;
    //< a string which matches the rule
      //   datearg >
      d = stringoroneword();
    {if (true) return d;}
    throw new Error("Missing return statement in function");
  }

// leafref path  static final public String pathargstr() throws ParseException {
  String p = "", pa = "";
    //	< a string which matches the rule
      //          patharg >
      p = stringoroneword();
    {if (true) return p + pa;}
    throw new Error("Missing return statement in function");
  }

// Basic Rules  static final public String prefixargstr() throws ParseException {
  String p = "";
    p = stringoroneword();
    {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public String identifierargstr() throws ParseException {
  String i = null;
    i = stringoroneword();
    {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

  static final public String identifierrefargstr() throws ParseException {
  String i = null;
    // < a string which matches the rule
      //   identifier-ref-arg
      i = stringoroneword();
    {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

  static final public String stringoroneword() throws ParseException {
  Token t;
  String s = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      s = string();
      break;
    case anyxmlkeyword:
    case argumentkeyword:
    case augmentkeyword:
    case basekeyword:
    case belongstokeyword:
    case bitkeyword:
    case casekeyword:
    case choicekeyword:
    case configkeyword:
    case contactkeyword:
    case containerkeyword:
    case defaultkeyword:
    case descriptionkeyword:
    case enumkeyword:
    case errorapptagkeyword:
    case errormessagekeyword:
    case extensionkeyword:
    case deviationkeyword:
    case deviatekeyword:
    case featurekeyword:
    case fractiondigitskeyword:
    case groupingkeyword:
    case identitykeyword:
    case iffeaturekeyword:
    case importkeyword:
    case includekeyword:
    case inputkeyword:
    case keykeyword:
    case leafkeyword:
    case leaflistkeyword:
    case lengthkeyword:
    case listkeyword:
    case mandatorykeyword:
    case maxelementskeyword:
    case minelementskeyword:
    case modulekeyword:
    case mustkeyword:
    case namespacekeyword:
    case notificationkeyword:
    case orderedbykeyword:
    case organizationkeyword:
    case outputkeyword:
    case pathkeyword:
    case patternkeyword:
    case positionkeyword:
    case prefixkeyword:
    case presencekeyword:
    case rangekeyword:
    case referencekeyword:
    case refinekeyword:
    case requireinstancekeyword:
    case revisionkeyword:
    case rpckeyword:
    case statuskeyword:
    case submodulekeyword:
    case typekeyword:
    case typedefkeyword:
    case uniquekeyword:
    case unitskeyword:
    case useskeyword:
    case valuekeyword:
    case whenkeyword:
    case yangversionkeyword:
    case yinelementkeyword:
    case addkeyword:
    case currentkeyword:
    case deprecatedkeyword:
    case deletekeyword:
    case falsekeyword:
    case minkeyword:
    case maxkeyword:
    case nankeyword:
    case neginfkeyword:
    case notsupportedkeyword:
    case obsoletekeyword:
    case posinfkeyword:
    case replacekeyword:
    case systemkeyword:
    case truekeyword:
    case unboundedkeyword:
    case userkeyword:
      s = anykeyword();
      break;
    case P:
    case S:
      if (jj_2_27(2)) {
        t = jj_consume_token(S);
      } else if (jj_2_28(2)) {
        t = jj_consume_token(P);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      s = t.image;
      break;
    default:
      jj_la1[142] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public String string() throws ParseException {
  Token s;
    s = jj_consume_token(STRING);
    {if (true) return YangBuiltInTypes.concat(s.image);}
    throw new Error("Missing return statement in function");
  }

  static final public void stmtend(YangNode zis) throws ParseException {
  YANG_Unknown un = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SC:
      jj_consume_token(SC);
      break;
    case LB:
      jj_consume_token(LB);
      optsep();
      label_61:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case P:
          ;
          break;
        default:
          jj_la1[143] = jj_gen;
          break label_61;
        }
        un = unknownstatement();
        zis.addUnknown(un);
      }
      jj_consume_token(RB);
      optsep();
      break;
    default:
      jj_la1[144] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void sep() throws ParseException {
    label_62:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WSP:
        jj_consume_token(WSP);
        break;
      case CRLF:
        linebreack();
        break;
      case CMT:
        jj_consume_token(CMT);
        break;
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CMT:
      case WSP:
      case CRLF:
        ;
        break;
      default:
        jj_la1[146] = jj_gen;
        break label_62;
      }
    }
  }

  static final public String optsep() throws ParseException {
  Token t = null;
  String o = "";
    label_63:
    while (true) {
      if (jj_2_29(2)) {
        ;
      } else {
        break label_63;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WSP:
        t = jj_consume_token(WSP);
        o = o + " ";
        break;
      case CRLF:
        linebreack();
        o = o + "\u005cn";
        break;
      case CMT:
        t = jj_consume_token(CMT);
        o = o + t.image;
        break;
      default:
        jj_la1[147] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return o;}
    throw new Error("Missing return statement in function");
  }

  static final public void stmtsep(YangNode zis) throws ParseException {
    label_64:
    while (true) {
      if (jj_2_30(2)) {
        ;
      } else {
        break label_64;
      }
      stmtsep2(zis);
    }
  }

  static final public void stmtsep2(YangNode zis) throws ParseException {
  YANG_Unknown un = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WSP:
      jj_consume_token(WSP);
      break;
    case CRLF:
      jj_consume_token(CRLF);
      break;
    case CMT:
      jj_consume_token(CMT);
      break;
    case P:
      un = unknownstatement();
      zis.addUnknown(un);
      break;
    default:
      jj_la1[148] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void linebreack() throws ParseException {
    jj_consume_token(CRLF);
  }

  static final public String anykeyword() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case anyxmlkeyword:
      t = jj_consume_token(anyxmlkeyword);
      break;
    case argumentkeyword:
      t = jj_consume_token(argumentkeyword);
      break;
    case augmentkeyword:
      t = jj_consume_token(augmentkeyword);
      break;
    case basekeyword:
      t = jj_consume_token(basekeyword);
      break;
    case belongstokeyword:
      t = jj_consume_token(belongstokeyword);
      break;
    case bitkeyword:
      t = jj_consume_token(bitkeyword);
      break;
    case casekeyword:
      t = jj_consume_token(casekeyword);
      break;
    case choicekeyword:
      t = jj_consume_token(choicekeyword);
      break;
    case configkeyword:
      t = jj_consume_token(configkeyword);
      break;
    case contactkeyword:
      t = jj_consume_token(contactkeyword);
      break;
    case containerkeyword:
      t = jj_consume_token(containerkeyword);
      break;
    case defaultkeyword:
      t = jj_consume_token(defaultkeyword);
      break;
    case descriptionkeyword:
      t = jj_consume_token(descriptionkeyword);
      break;
    case enumkeyword:
      t = jj_consume_token(enumkeyword);
      break;
    case errorapptagkeyword:
      t = jj_consume_token(errorapptagkeyword);
      break;
    case errormessagekeyword:
      t = jj_consume_token(errormessagekeyword);
      break;
    case extensionkeyword:
      t = jj_consume_token(extensionkeyword);
      break;
    case deviationkeyword:
      t = jj_consume_token(deviationkeyword);
      break;
    case deviatekeyword:
      t = jj_consume_token(deviatekeyword);
      break;
    case featurekeyword:
      t = jj_consume_token(featurekeyword);
      break;
    case fractiondigitskeyword:
      t = jj_consume_token(fractiondigitskeyword);
      break;
    case groupingkeyword:
      t = jj_consume_token(groupingkeyword);
      break;
    case identitykeyword:
      t = jj_consume_token(identitykeyword);
      break;
    case iffeaturekeyword:
      t = jj_consume_token(iffeaturekeyword);
      break;
    case importkeyword:
      t = jj_consume_token(importkeyword);
      break;
    case includekeyword:
      t = jj_consume_token(includekeyword);
      break;
    case inputkeyword:
      t = jj_consume_token(inputkeyword);
      break;
    case keykeyword:
      t = jj_consume_token(keykeyword);
      break;
    case leafkeyword:
      t = jj_consume_token(leafkeyword);
      break;
    case leaflistkeyword:
      t = jj_consume_token(leaflistkeyword);
      break;
    case lengthkeyword:
      t = jj_consume_token(lengthkeyword);
      break;
    case listkeyword:
      t = jj_consume_token(listkeyword);
      break;
    case mandatorykeyword:
      t = jj_consume_token(mandatorykeyword);
      break;
    case maxelementskeyword:
      t = jj_consume_token(maxelementskeyword);
      break;
    case minelementskeyword:
      t = jj_consume_token(minelementskeyword);
      break;
    case modulekeyword:
      t = jj_consume_token(modulekeyword);
      break;
    case mustkeyword:
      t = jj_consume_token(mustkeyword);
      break;
    case namespacekeyword:
      t = jj_consume_token(namespacekeyword);
      break;
    case notificationkeyword:
      t = jj_consume_token(notificationkeyword);
      break;
    case orderedbykeyword:
      t = jj_consume_token(orderedbykeyword);
      break;
    case organizationkeyword:
      t = jj_consume_token(organizationkeyword);
      break;
    case outputkeyword:
      t = jj_consume_token(outputkeyword);
      break;
    case pathkeyword:
      t = jj_consume_token(pathkeyword);
      break;
    case patternkeyword:
      t = jj_consume_token(patternkeyword);
      break;
    case positionkeyword:
      t = jj_consume_token(positionkeyword);
      break;
    case prefixkeyword:
      t = jj_consume_token(prefixkeyword);
      break;
    case presencekeyword:
      t = jj_consume_token(presencekeyword);
      break;
    case rangekeyword:
      t = jj_consume_token(rangekeyword);
      break;
    case referencekeyword:
      t = jj_consume_token(referencekeyword);
      break;
    case refinekeyword:
      t = jj_consume_token(refinekeyword);
      break;
    case requireinstancekeyword:
      t = jj_consume_token(requireinstancekeyword);
      break;
    case revisionkeyword:
      t = jj_consume_token(revisionkeyword);
      break;
    case rpckeyword:
      t = jj_consume_token(rpckeyword);
      break;
    case statuskeyword:
      t = jj_consume_token(statuskeyword);
      break;
    case submodulekeyword:
      t = jj_consume_token(submodulekeyword);
      break;
    case typekeyword:
      t = jj_consume_token(typekeyword);
      break;
    case typedefkeyword:
      t = jj_consume_token(typedefkeyword);
      break;
    case uniquekeyword:
      t = jj_consume_token(uniquekeyword);
      break;
    case unitskeyword:
      t = jj_consume_token(unitskeyword);
      break;
    case useskeyword:
      t = jj_consume_token(useskeyword);
      break;
    case valuekeyword:
      t = jj_consume_token(valuekeyword);
      break;
    case whenkeyword:
      t = jj_consume_token(whenkeyword);
      break;
    case yangversionkeyword:
      t = jj_consume_token(yangversionkeyword);
      break;
    case yinelementkeyword:
      t = jj_consume_token(yinelementkeyword);
      break;
    case addkeyword:
      t = jj_consume_token(addkeyword);
      break;
    case currentkeyword:
      t = jj_consume_token(currentkeyword);
      break;
    case deprecatedkeyword:
      t = jj_consume_token(deprecatedkeyword);
      break;
    case falsekeyword:
      t = jj_consume_token(falsekeyword);
      break;
    case deletekeyword:
      t = jj_consume_token(deletekeyword);
      break;
    case maxkeyword:
      t = jj_consume_token(maxkeyword);
      break;
    case minkeyword:
      t = jj_consume_token(minkeyword);
      break;
    case nankeyword:
      t = jj_consume_token(nankeyword);
      break;
    case neginfkeyword:
      t = jj_consume_token(neginfkeyword);
      break;
    case notsupportedkeyword:
      t = jj_consume_token(notsupportedkeyword);
      break;
    case obsoletekeyword:
      t = jj_consume_token(obsoletekeyword);
      break;
    case posinfkeyword:
      t = jj_consume_token(posinfkeyword);
      break;
    case replacekeyword:
      t = jj_consume_token(replacekeyword);
      break;
    case systemkeyword:
      t = jj_consume_token(systemkeyword);
      break;
    case truekeyword:
      t = jj_consume_token(truekeyword);
      break;
    case unboundedkeyword:
      t = jj_consume_token(unboundedkeyword);
      break;
    case userkeyword:
      t = jj_consume_token(userkeyword);
      break;
    default:
      jj_la1[149] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  static private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  static private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  static private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  static private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  static private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  static private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  static private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  static private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  static private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  static private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  static private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  static private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  static private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  static private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  static private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  static private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  static private boolean jj_3R_115() {
    if (jj_scan_token(useskeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_95() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_scan_token(groupingkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_71() {
    if (jj_scan_token(requireinstancekeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_79() {
    if (jj_scan_token(iffeaturekeyword)) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_3R_80() {
    if (jj_scan_token(statuskeyword)) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  static private boolean jj_3_26() {
    if (jj_3R_86()) return true;
    return false;
  }

  static private boolean jj_3R_68() {
    if (jj_scan_token(rangekeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    if (jj_scan_token(referencekeyword)) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_91() {
    if (jj_scan_token(pathkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_110() {
    if (jj_scan_token(leafkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_112() {
    if (jj_scan_token(listkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_3R_71()) return true;
    return false;
  }

  static private boolean jj_3R_113() {
    if (jj_scan_token(choicekeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_70() {
    if (jj_scan_token(lengthkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_66() {
    if (jj_3R_91()) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    if (jj_scan_token(descriptionkeyword)) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_77() {
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_67()) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_3R_70()) return true;
    return false;
  }

  static private boolean jj_3R_108() {
    if (jj_3R_116()) return true;
    return false;
  }

  static private boolean jj_3R_114() {
    if (jj_scan_token(anyxmlkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_76() {
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    return false;
  }

  static private boolean jj_3R_107() {
    if (jj_3R_115()) return true;
    return false;
  }

  static private boolean jj_3R_106() {
    if (jj_3R_114()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_66()) return true;
    return false;
  }

  static private boolean jj_3R_105() {
    if (jj_3R_113()) return true;
    return false;
  }

  static private boolean jj_3R_104() {
    if (jj_3R_112()) return true;
    return false;
  }

  static private boolean jj_3R_78() {
    if (jj_scan_token(whenkeyword)) return true;
    if (jj_3R_83()) return true;
    if (jj_3R_94()) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_103() {
    if (jj_3R_111()) return true;
    return false;
  }

  static private boolean jj_3R_102() {
    if (jj_3R_110()) return true;
    return false;
  }

  static private boolean jj_3R_101() {
    if (jj_3R_109()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_65()) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_69()) return true;
    return false;
  }

  static private boolean jj_3_25() {
    if (jj_3R_86()) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_30() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_69()) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    if (jj_scan_token(CMT)) return true;
    return false;
  }

  static private boolean jj_3R_73() {
    if (jj_scan_token(bitkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_scan_token(4)) return true;
    return false;
  }

  static private boolean jj_3R_65() {
    if (jj_scan_token(enumkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_23() {
    if (jj_3R_83()) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_87() {
    if (jj_scan_token(WSP)) return true;
    return false;
  }

  static private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_72() {
    if (jj_scan_token(typekeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_117() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_22() {
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3_20() {
    if (jj_scan_token(P)) return true;
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_3R_73()) return true;
    return false;
  }

  static private boolean jj_3_19() {
    if (jj_scan_token(S)) return true;
    return false;
  }

  static private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_109() {
    if (jj_scan_token(containerkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_24() {
    if (jj_3R_86()) return true;
    return false;
  }

  static private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3_20()) return true;
    }
    return false;
  }

  static private boolean jj_3R_83() {
    Token xsp;
    if (jj_3R_97()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_97()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_111() {
    if (jj_scan_token(leaflistkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_3R_72()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_68()) return true;
    return false;
  }

  static private boolean jj_3_17() {
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_118() {
    if (jj_scan_token(LB)) return true;
    return false;
  }

  static private boolean jj_3R_67() {
    Token xsp;
    if (jj_3_9()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_94() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  static private boolean jj_3_16() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3_15() {
    if (jj_3R_80()) return true;
    return false;
  }

  static private boolean jj_3_18() {
    if (jj_3R_83()) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_75() {
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3R_74() {
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3_14() {
    if (jj_3R_79()) return true;
    return false;
  }

  static private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    return false;
  }

  static private boolean jj_3_28() {
    if (jj_scan_token(P)) return true;
    return false;
  }

  static private boolean jj_3R_92() {
    if (jj_scan_token(typedefkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_27() {
    if (jj_scan_token(S)) return true;
    return false;
  }

  static private boolean jj_3_13() {
    if (jj_3R_78()) return true;
    return false;
  }

  static private boolean jj_3R_116() {
    if (jj_scan_token(P)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    return false;
  }

  static private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) return true;
    }
    return false;
  }

  static private boolean jj_3R_99() {
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    if (jj_3R_94()) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_96() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_69() {
    if (jj_scan_token(patternkeyword)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public yangTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[150];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x120000,0x0,0x6b048500,0x1000,0x0,0x120000,0x0,0x6b048500,0x0,0x1000,0x120000,0x0,0x6b048500,0x48100,0x0,0x0,0x0,0xa0,0x100000,0x0,0xa0,0x100200,0x100200,0xa0,0x0,0xa0,0x100800,0x100800,0xa0,0x80100000,0x80100000,0xa0,0x180000,0x180000,0x10202800,0x10200000,0x2800,0xa0,0xd00000,0xd00000,0xa0,0x0,0xd00000,0xd00000,0xa0,0xd00000,0xd00000,0xa0,0x100000,0x100000,0xa0,0x100000,0x100000,0xa0,0xd00000,0xd00000,0xa0,0x20148100,0x20000000,0x20148100,0xa0,0xa0158100,0x20000000,0xa0158100,0xa0,0x80190000,0x80190000,0x80110000,0x80110000,0xa0158100,0xa0158100,0x801d4100,0x801d4100,0xa0,0x40100,0x80148100,0x80148100,0xa0,0x80110000,0x80110000,0xa0,0x80100400,0x400,0xa0,0x190000,0x190000,0xa0,0x110000,0x110000,0x190000,0x190000,0x110000,0x110000,0x110000,0x110000,0x190000,0x190000,0x100000,0x100000,0x8014c100,0x4c100,0x8014c100,0x8014c100,0x4c100,0x8014c100,0xffffff1a,0xa0,0xffffff1a,0xa0,0x100000,0x100000,0xa0,0xa0100000,0x20000000,0xa0100000,0xa0,0x20048100,0x20000000,0x20048100,0x20048100,0x20000000,0x20048100,0xa0148100,0x20000000,0xa0148100,0xa0,0x0,0x4100000,0x4100000,0xa0,0x90000,0x90000,0xa0,0x80000,0x80000,0xa0,0x90000,0x90000,0xa0,0xffffff04,0x0,0xa0,0x1a,0x1a,0x1a,0x1a,0xffffff00,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x80000800,0x202000,0x3,0x1010000,0x8000000,0x200040b0,0x0,0x3,0x1010000,0x8000000,0x200040b0,0x202000,0x0,0x1010000,0x3,0x200040b0,0xb0,0x200000,0x10000000,0x10000000,0x0,0x0,0x1000000,0x0,0x41000000,0x41000000,0x0,0x0,0x0,0x41000000,0x41000000,0x0,0x41000000,0x41000000,0x0,0x41000000,0x41000000,0x48c0040,0x880040,0x4000000,0x0,0x1000000,0x1000000,0x0,0x80040,0x1000000,0x1000000,0x0,0x1000000,0x1000000,0x0,0x41000000,0x41000000,0x0,0x41100000,0x41100000,0x0,0x1000000,0x1000000,0x0,0x410000b0,0x0,0x410000b0,0x0,0x414010b0,0x0,0x414010b0,0x0,0x41001100,0x41001100,0x41009600,0x41009600,0x410096b8,0x410096b8,0x410001b0,0x410001b0,0x0,0xb0,0x410000b0,0x410000b0,0x0,0x41001100,0x41001100,0x0,0x43000000,0x2000000,0x0,0x1401700,0x1401700,0x0,0x1401000,0x1401000,0x1001100,0x1001100,0x1001600,0x1001600,0x1001600,0x1001600,0x1000100,0x1000100,0x1000000,0x1001100,0x410000b0,0xb0,0x410000b0,0x410000b0,0xb0,0x410000b0,0xefffffff,0x0,0xefffffff,0x0,0x1000000,0x1000000,0x0,0x41020004,0x0,0x41020004,0x0,0xb0,0x0,0xb0,0xb0,0x0,0xb0,0x410000b0,0x0,0x410000b0,0x0,0x0,0x1000000,0x1000000,0x0,0x1700,0x1700,0x0,0x1000,0x1000,0x0,0x700,0x700,0x0,0xefffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xefffffff,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x80,0x0,0x0,0x0,0x12,0x80,0x0,0x0,0x0,0x12,0x80,0x80,0x0,0x0,0x12,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x9,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x12,0x2,0x12,0x0,0x52,0x2,0x52,0x0,0x49,0x49,0x49,0x49,0x56,0x56,0x40,0x40,0x0,0x0,0x50,0x50,0x0,0x40,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50,0x10,0x50,0x50,0x10,0x50,0xfffffff,0x0,0xfffffff,0x0,0x0,0x0,0x0,0x2,0x2,0x2,0x0,0x12,0x2,0x12,0x12,0x2,0x12,0x12,0x2,0x12,0x0,0x241200,0x0,0x0,0x0,0xc,0xc,0x0,0xc,0xc,0x0,0x9,0x9,0x0,0xfffffff,0x4000000,0x0,0x0,0x0,0x0,0x4000000,0x3ffffff,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[30];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public yang(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public yang(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new yangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public yang(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new yangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public yang(yangTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(yangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 150; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[92];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 150; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 92; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 30; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
